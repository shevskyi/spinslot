<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gates of Olympus - Clean Implementation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            max-width: calc(100vh * 9/16); /* 9:16 ratio */
            background: linear-gradient(135deg, #1a0e3a 0%, #2d1b69 100%);
            background-image: url('assets/png/background/Basegame_BG.png');
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }

        /* Zeus */
        .zeus-container {
            position: absolute;
            left: 0px;
            top: 0px;
            pointer-events: none;
            z-index: 50;
            width: 35%;
            transform: translate(36px, 100px) translate(-50%, -50%);
        }

        .zeus-img {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        /* Zeus position states - exact coordinates for each position */
        .zeus-container.at-left {
            left: 20%;
            transform: translateX(-50%) rotateY(-15deg);
        }

        .zeus-container.at-center {
            left: 50%;
            transform: translateX(-50%) rotateY(0deg);
        }

        .zeus-container.at-right {
            left: 80%;
            transform: translateX(-50%) rotateY(15deg);
        }

        /* Zeus movement animations with exact coordinates */
        @keyframes zeusFloatIdleCenter {
            0%, 100% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
            50% {
                left: 50%;
                transform: translateX(-50%) translateY(-8px) rotateY(0deg) scale(1.01);
            }
        }

        @keyframes zeusFloatIdleLeft {
            0%, 100% {
                left: 20%;
                transform: translateX(-50%) translateY(0px) rotateY(-15deg) scale(1);
            }
            50% {
                left: 20%;
                transform: translateX(-50%) translateY(-8px) rotateY(-15deg) scale(1.01);
            }
        }

        @keyframes zeusFloatIdleRight {
            0%, 100% {
                left: 80%;
                transform: translateX(-50%) translateY(0px) rotateY(15deg) scale(1);
            }
            50% {
                left: 80%;
                transform: translateX(-50%) translateY(-8px) rotateY(15deg) scale(1.01);
            }
        }

        /* LEFT TO CENTER - Ultra Smooth */
        @keyframes zeusMoveLeftToCenter {
            0% {
                left: 20%;
                transform: translateX(-50%) translateY(0px) rotateY(-15deg) scale(1);
            }
            8% {
                left: 22%;
                transform: translateX(-50%) translateY(-1px) rotateY(-14deg) scale(1.005);
            }
            15% {
                left: 25%;
                transform: translateX(-50%) translateY(-2px) rotateY(-12deg) scale(1.01);
            }
            25% {
                left: 30%;
                transform: translateX(-50%) translateY(-3px) rotateY(-10deg) scale(1.02);
            }
            35% {
                left: 35%;
                transform: translateX(-50%) translateY(-4px) rotateY(-8deg) scale(1.03);
            }
            50% {
                left: 42%;
                transform: translateX(-50%) translateY(-5px) rotateY(-5deg) scale(1.025);
            }
            65% {
                left: 45%;
                transform: translateX(-50%) translateY(-3px) rotateY(-3deg) scale(1.015);
            }
            80% {
                left: 47%;
                transform: translateX(-50%) translateY(-2px) rotateY(-1.5deg) scale(1.008);
            }
            90% {
                left: 49%;
                transform: translateX(-50%) translateY(-1px) rotateY(-0.5deg) scale(1.003);
            }
            100% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
        }

        /* LEFT TO RIGHT - Ultra Smooth */
        @keyframes zeusMoveLeftToRight {
            0% {
                left: 20%;
                transform: translateX(-50%) translateY(0px) rotateY(-15deg) scale(1);
            }
            6% {
                left: 24%;
                transform: translateX(-50%) translateY(-2px) rotateY(-12deg) scale(1.01);
            }
            12% {
                left: 28%;
                transform: translateX(-50%) translateY(-4px) rotateY(-8deg) scale(1.03);
            }
            20% {
                left: 34%;
                transform: translateX(-50%) translateY(-6px) rotateY(-5deg) scale(1.05);
            }
            30% {
                left: 40%;
                transform: translateX(-50%) translateY(-8px) rotateY(-2deg) scale(1.07);
            }
            40% {
                left: 46%;
                transform: translateX(-50%) translateY(-9px) rotateY(0deg) scale(1.08);
            }
            50% {
                left: 50%;
                transform: translateX(-50%) translateY(-10px) rotateY(0deg) scale(1.09);
            }
            60% {
                left: 54%;
                transform: translateX(-50%) translateY(-9px) rotateY(2deg) scale(1.08);
            }
            70% {
                left: 60%;
                transform: translateX(-50%) translateY(-8px) rotateY(5deg) scale(1.06);
            }
            80% {
                left: 66%;
                transform: translateX(-50%) translateY(-6px) rotateY(8deg) scale(1.04);
            }
            88% {
                left: 72%;
                transform: translateX(-50%) translateY(-4px) rotateY(12deg) scale(1.02);
            }
            94% {
                left: 76%;
                transform: translateX(-50%) translateY(-2px) rotateY(14deg) scale(1.01);
            }
            100% {
                left: 80%;
                transform: translateX(-50%) translateY(0px) rotateY(15deg) scale(1);
            }
        }

        /* CENTER TO LEFT - Ultra Smooth */
        @keyframes zeusMoveenterToLeft {
            0% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
            8% {
                left: 48%;
                transform: translateX(-50%) translateY(-1px) rotateY(-1deg) scale(1.005);
            }
            15% {
                left: 45%;
                transform: translateX(-50%) translateY(-2px) rotateY(-2deg) scale(1.01);
            }
            25% {
                left: 40%;
                transform: translateX(-50%) translateY(-3px) rotateY(-4deg) scale(1.02);
            }
            35% {
                left: 35%;
                transform: translateX(-50%) translateY(-4px) rotateY(-6deg) scale(1.03);
            }
            50% {
                left: 28%;
                transform: translateX(-50%) translateY(-5px) rotateY(-9deg) scale(1.025);
            }
            65% {
                left: 25%;
                transform: translateX(-50%) translateY(-3px) rotateY(-11deg) scale(1.015);
            }
            80% {
                left: 23%;
                transform: translateX(-50%) translateY(-2px) rotateY(-13deg) scale(1.008);
            }
            90% {
                left: 21%;
                transform: translateX(-50%) translateY(-1px) rotateY(-14deg) scale(1.003);
            }
            100% {
                left: 20%;
                transform: translateX(-50%) translateY(0px) rotateY(-15deg) scale(1);
            }
        }

        /* CENTER TO RIGHT - Ultra Smooth */
        @keyframes zeusMoveenterToRight {
            0% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
            8% {
                left: 52%;
                transform: translateX(-50%) translateY(-1px) rotateY(1deg) scale(1.005);
            }
            15% {
                left: 55%;
                transform: translateX(-50%) translateY(-2px) rotateY(2deg) scale(1.01);
            }
            25% {
                left: 60%;
                transform: translateX(-50%) translateY(-3px) rotateY(4deg) scale(1.02);
            }
            35% {
                left: 65%;
                transform: translateX(-50%) translateY(-4px) rotateY(6deg) scale(1.03);
            }
            50% {
                left: 72%;
                transform: translateX(-50%) translateY(-5px) rotateY(9deg) scale(1.025);
            }
            65% {
                left: 75%;
                transform: translateX(-50%) translateY(-3px) rotateY(11deg) scale(1.015);
            }
            80% {
                left: 77%;
                transform: translateX(-50%) translateY(-2px) rotateY(13deg) scale(1.008);
            }
            90% {
                left: 79%;
                transform: translateX(-50%) translateY(-1px) rotateY(14deg) scale(1.003);
            }
            100% {
                left: 80%;
                transform: translateX(-50%) translateY(0px) rotateY(15deg) scale(1);
            }
        }

        /* RIGHT TO CENTER - Ultra Smooth */
        @keyframes zeusMoveRightToCenter {
            0% {
                left: 80%;
                transform: translateX(-50%) translateY(0px) rotateY(15deg) scale(1);
            }
            8% {
                left: 78%;
                transform: translateX(-50%) translateY(-1px) rotateY(13deg) scale(1.005);
            }
            15% {
                left: 75%;
                transform: translateX(-50%) translateY(-2px) rotateY(11deg) scale(1.01);
            }
            25% {
                left: 70%;
                transform: translateX(-50%) translateY(-3px) rotateY(9deg) scale(1.02);
            }
            35% {
                left: 65%;
                transform: translateX(-50%) translateY(-4px) rotateY(7deg) scale(1.03);
            }
            50% {
                left: 58%;
                transform: translateX(-50%) translateY(-5px) rotateY(4deg) scale(1.025);
            }
            65% {
                left: 55%;
                transform: translateX(-50%) translateY(-3px) rotateY(3deg) scale(1.015);
            }
            80% {
                left: 53%;
                transform: translateX(-50%) translateY(-2px) rotateY(2deg) scale(1.008);
            }
            90% {
                left: 51%;
                transform: translateX(-50%) translateY(-1px) rotateY(1deg) scale(1.003);
            }
            100% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
        }

        /* RIGHT TO LEFT - Ultra Smooth */
        @keyframes zeusMoveRightToLeft {
            0% {
                left: 80%;
                transform: translateX(-50%) translateY(0px) rotateY(15deg) scale(1);
            }
            8% {
                left: 76%;
                transform: translateX(-50%) translateY(-2px) rotateY(11deg) scale(1.02);
            }
            12% {
                left: 72%;
                transform: translateX(-50%) translateY(-4px) rotateY(8deg) scale(1.035);
            }
            20% {
                left: 66%;
                transform: translateX(-50%) translateY(-6px) rotateY(5deg) scale(1.05);
            }
            25% {
                left: 62%;
                transform: translateX(-50%) translateY(-8px) rotateY(3deg) scale(1.065);
            }
            35% {
                left: 56%;
                transform: translateX(-50%) translateY(-10px) rotateY(1deg) scale(1.08);
            }
            50% {
                left: 50%;
                transform: translateX(-50%) translateY(-12px) rotateY(0deg) scale(1.1);
            }
            65% {
                left: 44%;
                transform: translateX(-50%) translateY(-10px) rotateY(-3deg) scale(1.08);
            }
            75% {
                left: 38%;
                transform: translateX(-50%) translateY(-8px) rotateY(-6deg) scale(1.06);
            }
            82% {
                left: 34%;
                transform: translateX(-50%) translateY(-6px) rotateY(-9deg) scale(1.04);
            }
            88% {
                left: 28%;
                transform: translateX(-50%) translateY(-4px) rotateY(-12deg) scale(1.02);
            }
            95% {
                left: 23%;
                transform: translateX(-50%) translateY(-2px) rotateY(-14deg) scale(1.01);
            }
            100% {
                left: 20%;
                transform: translateX(-50%) translateY(0px) rotateY(-15deg) scale(1);
            }
        }

        /* SPECIAL ANIMATIONS */
        @keyframes zeusGrandEntrance {
            0% {
                left: -20%;
                transform: translateX(-50%) translateY(-15px) rotateY(-30deg) scale(0.8);
                opacity: 0.7;
            }
            50% {
                left: 25%;
                transform: translateX(-50%) translateY(-15px) rotateY(10deg) scale(1.1);
                opacity: 1;
            }
            100% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes zeusCelebration {
            0%, 100% {
                left: 50%;
                transform: translateX(-50%) translateY(0px) rotateY(0deg) scale(1);
            }
            25% {
                left: 50%;
                transform: translateX(-50%) translateY(-15px) rotateY(15deg) scale(1.15);
            }
            50% {
                left: 50%;
                transform: translateX(-50%) translateY(-10px) rotateY(-15deg) scale(1.1);
            }
            75% {
                left: 50%;
                transform: translateX(-50%) translateY(-20px) rotateY(10deg) scale(1.2);
            }
        }

        /* Animation classes */
        .zeus-container.floating-center {
            animation: zeusFloatIdleCenter 4s ease-in-out infinite;
        }

        .zeus-container.floating-left {
            animation: zeusFloatIdleLeft 4s ease-in-out infinite;
        }

        .zeus-container.floating-right {
            animation: zeusFloatIdleRight 4s ease-in-out infinite;
        }

        .zeus-container.move-left-to-center {
            animation: zeusMoveLeftToCenter 3.2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.move-left-to-right {
            animation: zeusMoveLeftToRight 3.8s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.move-right-to-center {
            animation: zeusMoveRightToCenter 3.2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.move-right-to-left {
            animation: zeusMoveRightToLeft 3.8s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.move-center-to-left {
            animation: zeusMoveenterToLeft 3.2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.move-center-to-right {
            animation: zeusMoveenterToRight 3.2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        .zeus-container.grand-entrance {
            animation: zeusGrandEntrance 3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .zeus-container.celebrating {
            animation: zeusCelebration 1.5s ease-in-out infinite;
        }

        /* Zeus lightning effects for mega wins */
        .lightning-video {
            position: absolute;
            width: 300px;
            height: 400px;
            z-index: 9998; /* Just below Zeus */
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            mix-blend-mode: screen; /* Chromakey effect */
            filter: contrast(1.2) brightness(1.1); /* Enhance lightning visibility */
        }

        .lightning-video.active {
            opacity: 1;
        }

        .lightning-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Additional video processing for better chromakey */
            filter: contrast(1.3) brightness(1.2) saturate(1.1);
        }

        /* Screen flash effect */
        .lightning-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(135, 206, 235, 0.3);
            z-index: 9997;
            opacity: 0;
            pointer-events: none;
        }

        @keyframes screenFlash {
            0% { opacity: 0; }
            10% { opacity: 0.8; }
            20% { opacity: 0.2; }
            30% { opacity: 0.9; }
            40% { opacity: 0.1; }
            50% { opacity: 0.7; }
            100% { opacity: 0; }
        }

        .lightning-flash.active {
            animation: screenFlash 1s ease-out forwards;
        }

        /* Main Win Board */
        .main-win-board {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: 520px;
            max-width: 85%;
            height:37px;
            background: linear-gradient(180deg, #3a0f12 0%, #6b1f25 55%, #4a0f12 100%); /* deep red bar */
            border: 4px solid #c68b00; /* warm gold border */
            border-radius: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.6),
                inset 0 0 18px rgba(0,0,0,0.25),
                0 0 24px rgba(255, 200, 20, 0.12);
            backdrop-filter: blur(2px);
            padding: 6px 14px;
        }

        .win-board-content {
            display: flex;
            align-items: center;
            gap: 14px;
            width: 100%;
            justify-content: center;
        }

        .win-board-label {
            color: #ffd84d;
            font-size: 0.78rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.6px;
            text-shadow: 0 0 8px rgba(255,220,120,0.12);
            margin: 0;
            padding: 0 6px;
        }

        .total-win-amount {
            color: #fffb7a;
            font-size: 1.5rem;
            font-weight: 900;
            letter-spacing: 1px;
            text-shadow: 
                0 0 6px rgba(255,255,255,0.6),
                0 6px 18px rgba(255, 90, 140, 0.08),
                0 0 18px rgba(255,215,0,0.35);
            min-height: 1.5rem;
            line-height: 1.2;
            padding: 2px 10px;
            background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(255,255,255,0.02));
            border-radius: 8px;
        }

        /* Previous Win Block */
        .previous-win-block {
              position: fixed;
    bottom:160px;
    left: 50%;
    transform: translateX(-50%);
    width: 10px;
    max-width: 400px;
    min-width: 150px;
    height: 47px;
    background: linear-gradient(45deg, #0a0a1a, #1a1a2e);
    border: 2px solid #888;
    border-radius: 8px;
    display: flex
;
    align-items: center;
    justify-content: center;
    z-index: 999;
    box-shadow: 0 0 15px rgba(136, 136, 136, 0.3), inset 0 0 10px rgba(136, 136, 136, 0.1);
    backdrop-filter: blur(5px);
    opacity: 0.9;
    transition: none;
        }

        .previous-win-block.highlight {
            border-color: #FFD700;
            box-shadow: 
                0 0 20px rgba(255, 215, 0, 0.6),
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 0 15px rgba(255, 215, 0, 0.1);
            opacity: 1;
            /* Remove animation to prevent jumping */
        }

        .previous-win-content {
            text-align: center;
            width: 100%;
        }

        .previous-win-label {
            color: #ccc;
            font-size: 0.7rem;
            font-weight: bold;
            margin-bottom: 0.1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            letter-spacing: 0.5px;
        }

        .previous-win-amount {
            color: #fff;
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 
                0 0 8px #FFD700,
                1px 1px 2px rgba(0,0,0,0.8);
            min-height: 1.4rem;
            line-height: 1.4rem;
        }

        /* Slot Area */
        .slot-area {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%) rotate(180deg) scaleX(-1);
            width: 85%;
            height: 40%;
            display: flex;
            gap: 2%;
            justify-content: space-between;
            z-index: 5;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .reel {
            width: 18%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .symbols-column {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 400%; /* 24 symbols = 4x normal height */
            transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        /* Each column contains 24 items; each .symbol-item must be exactly 1/24 of column height
           which gives 6 visible items when column height is 400% and reel viewport is 100% */
        .symbol-item {
            width: 100%;
            /* fixed symbol height via CSS variable to avoid layout jumps
               default falls back to 1/24 if variable isn't set */
            height: var(--symbol-height, calc(100% / 24));
            min-height: var(--symbol-height, calc(100% / 24));
            max-height: var(--symbol-height, calc(100% / 24));
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            position: relative;
        }

        .symbol-item img {
            width: 92%;
            height: 92%;
            object-fit: contain;
            display: block;
            margin: 0;
            padding: 0;
            transform: rotate(180deg) scaleX(1) !important;
        }

        .symbol-item.winning {
            z-index: 10;
            position: relative;
            border: 3px solid #ffd700 !important;
            box-shadow: 
                0 0 10px #ffd700,
                0 0 20px #ffd700,
                0 0 30px #ffd700,
                inset 0 0 10px rgba(255, 215, 0, 0.3);
        }







        /* UI */
        .ui-container {
            position: absolute;
            bottom: 4%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            z-index: 15;
            pointer-events: none; /* Allow interactions to pass through */
        }

        .title {
            color: #fff;
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .subtitle {
            display: none; /* Hide subtitle */
        }

        /* Hide textual UI elements under the spin button per request */

        .ui-container .subtitle,
        .ui-container #win-status,
        .previous-win-block {
            display: none !important;
        }

        .win-status {
            color: #FFD700;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 
                0 0 10px #FFD700,
                0 0 20px #FFD700,
                2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .win-status.show {
            opacity: 1;
        }

        .win-status.small {
            color: #90EE90;
            text-shadow: 
                0 0 10px #90EE90,
                0 0 20px #90EE90,
                2px 2px 4px rgba(0,0,0,0.8);
        }

        .win-status.medium {
            color: #FFD700;
            text-shadow: 
                0 0 10px #FFD700,
                0 0 20px #FFD700,
                2px 2px 4px rgba(0,0,0,0.8);
        }

        .win-status.big {
            color: #FF6347;
            font-size: 2.2em;
            text-shadow: 
                0 0 15px #FF6347,
                0 0 30px #FF6347,
                2px 2px 4px rgba(0,0,0,0.8);
        }

        .win-status.mega {
            color: #FF1493;
            font-size: 2.5em;
            text-shadow: 
                0 0 20px #FF1493,
                0 0 40px #FF1493,
                2px 2px 4px rgba(0,0,0,0.8);
            animation: winPulse 1s ease-in-out infinite;
        }

        .win-status.none {
            color: #87CEEB;
            font-size: 1.5em;
            text-shadow: 
                0 0 8px #87CEEB,
                2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% {  }
        }

        .spin-btn {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.4em;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin: 0 auto;
            bottom: 6%;
            z-index: 1000;
            min-width: 200px;
            pointer-events: auto; /* Enable interactions */
        }

        .spin-btn:hover {

            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .spin-btn:active {
            /* Keep centered and only do a small press animation vertically */
            transform: translateY(3px) scale(0.995);
            transition: transform 120ms ease;
        }

        .spin-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Bonus button styling */
        .spin-btn.bonus-btn {
            background: linear-gradient(45deg, #28a745, #20c997) !important;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.6) !important;
            animation: bonusPulse 1.5s ease-in-out infinite;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spin-btn.bonus-btn:hover {
            background: linear-gradient(45deg, #218838, #17a2b8) !important;
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.8) !important;
        }

        /* Collect bonus button styling */
        .spin-btn.collect-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500) !important;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.8) !important;
            animation: collectPulse 1.2s ease-in-out infinite;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6em !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .spin-btn.collect-btn:hover {
            background: linear-gradient(45deg, #FFA500, #FF8C00) !important;
            box-shadow: 0 6px 25px rgba(255, 215, 0, 1) !important;
        }

        @keyframes collectPulse {
            0%, 100% {
                transform: translateY(-2px) scale(1);
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.8);
            }
            50% {
                transform: translateY(-4px) scale(1.05);
                box-shadow: 0 8px 25px rgba(255, 215, 0, 1);
            }
        }

        @keyframes bonusPulse {
            0%, 100% {
                transform: translateY(-2px) scale(1);
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.6);
            }
            50% {
                transform: translateY(-2px) scale(1.05);
                box-shadow: 0 6px 25px rgba(40, 167, 69, 0.8);
            }
        }

        /* Win amount animation effects */
        @keyframes totalWinUpdate {
            0% { 
                transform: scale(1);
                color: #fff;
            }
            30% { 
                transform: scale(1.3);
                color: #FFD700;
                text-shadow: 
                    0 0 25px #FFD700,
                    0 0 50px #FFD700,
                    0 0 75px #FFF700;
            }
            60% { 
                transform: scale(1.15);
                color: #FFF700;
                text-shadow: 
                    0 0 30px #FFD700,
                    0 0 60px #FFF700;
            }
            100% { 
                transform: scale(1);
                color: #fff;
            }
        }

        @keyframes winBoardPulse {
            0% {
                border-color: #FFD700;
                box-shadow: 
                    0 0 25px rgba(255, 215, 0, 0.6),
                    0 0 40px rgba(255, 215, 0, 0.3),
                    inset 0 0 15px rgba(255, 215, 0, 0.1);
            }
            50% {
                border-color: #FFF700;
                box-shadow: 
                    0 0 40px rgba(255, 215, 0, 0.9),
                    0 0 60px rgba(255, 247, 0, 0.6),
                    0 0 80px rgba(255, 255, 255, 0.3),
                    inset 0 0 25px rgba(255, 215, 0, 0.2);
            }
            100% {
                border-color: #FFD700;
                box-shadow: 
                    0 0 25px rgba(255, 215, 0, 0.6),
                    0 0 40px rgba(255, 215, 0, 0.3),
                    inset 0 0 15px rgba(255, 215, 0, 0.1);
            }
        }

        @keyframes winAmountFly {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            20% {
                opacity: 0.9;
                transform: scale(1.3) rotate(5deg);
            }
            60% {
                opacity: 0.7;
                transform: scale(1.1) rotate(-3deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-120px) rotate(0deg);
            }
        }

        /* Flying coin effect */
        .flying-win {
            position: absolute;
            color: #FFD700;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 
                0 0 15px #FFD700,
                0 0 30px #FFD700,
                0 0 45px #FFF700;
            z-index: 25;
            pointer-events: none;
            animation: winAmountFly 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* Enhanced win symbol effects */
        /* Animate the symbol image itself - simplified */
        .symbol-item.winning img {
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .symbol-item.winning.small-win img {
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .symbol-item.winning.medium-win img {
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .symbol-item.winning.big-win img {
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .symbol-item.winning.mega-win img {
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        /* Symbol particle animations for different win levels - simplified */
        /* Animations for explosions above slots */
        @keyframes aboveSlotParticleFly {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) rotate(var(--angle)) translateX(0) scale(1);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) rotate(var(--angle)) translateX(calc(var(--distance) * 0.3)) scale(1.2);
            }
            80% {
                opacity: 0.5;
                transform: translate(-50%, -50%) rotate(var(--angle)) translateX(calc(var(--distance) * 0.9)) scale(0.8);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) rotate(var(--angle)) translateX(var(--distance)) scale(0.3);
            }
        }

        @keyframes centralBurst {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(4);
            }
        }

        /* Sparks container styling */
        .sparks-container {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
            z-index: 250 !important;
            overflow: visible !important;
        }

        .spark {
            position: absolute !important;
            border-radius: 50% !important;
            pointer-events: none !important;
        }

        @keyframes explosionBorder {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 0.3;
                background: radial-gradient(
                    circle, 
                    transparent 40%, 
                    rgba(255, 215, 0, 0.3) 50%, 
                    rgba(255, 247, 0, 0.5) 60%, 
                    rgba(255, 255, 255, 0.4) 70%, 
                    transparent 80%
                );
            }
            25% {
                transform: scale(1.15) rotate(90deg);
                opacity: 0.7;
                background: radial-gradient(
                    circle, 
                    transparent 30%, 
                    rgba(255, 215, 0, 0.5) 40%, 
                    rgba(255, 247, 0, 0.7) 50%, 
                    rgba(255, 255, 255, 0.6) 60%, 
                    rgba(135, 206, 235, 0.3) 70%, 
                    transparent 85%
                );
            }
            50% {
                transform: scale(1.3) rotate(180deg);
                opacity: 0.9;
                background: radial-gradient(
                    circle, 
                    transparent 20%, 
                    rgba(255, 215, 0, 0.7) 30%, 
                    rgba(255, 247, 0, 0.9) 40%, 
                    rgba(255, 255, 255, 0.8) 50%, 
                    rgba(135, 206, 235, 0.5) 60%, 
                    transparent 75%
                );
            }
            75% {
                transform: scale(1.2) rotate(270deg);
                opacity: 0.6;
                background: radial-gradient(
                    circle, 
                    transparent 35%, 
                    rgba(255, 215, 0, 0.4) 45%, 
                    rgba(255, 247, 0, 0.6) 55%, 
                    rgba(255, 255, 255, 0.5) 65%, 
                    transparent 80%
                );
            }
            100% {
                transform: scale(1) rotate(360deg);
                opacity: 0.3;
                background: radial-gradient(
                    circle, 
                    transparent 40%, 
                    rgba(255, 215, 0, 0.3) 50%, 
                    rgba(255, 247, 0, 0.5) 60%, 
                    rgba(255, 255, 255, 0.4) 70%, 
                    transparent 80%
                );
            }
        }

        @keyframes explosionRotate {
            0% {
                transform: scale(1.1) rotate(0deg);
                opacity: 0.4;
            }
            25% {
                transform: scale(1.25) rotate(90deg);
                opacity: 0.6;
            }
            50% {
                transform: scale(1.4) rotate(180deg);
                opacity: 0.8;
            }
            75% {
                transform: scale(1.3) rotate(270deg);
                opacity: 0.5;
            }
            100% {
                transform: scale(1.1) rotate(360deg);
                opacity: 0.4;
            }
        }

        /* Particles effect around winning symbols */
        .symbol-item.winning .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
        }

        .particle.spark-1 {
            top: 10%;
            left: 10%;
        }

        .particle.spark-2 {
            top: 10%;
            right: 10%;
        }

        .particle.spark-3 {
            bottom: 10%;
            left: 10%;
        }

        .particle.spark-4 {
            bottom: 10%;
            right: 10%;
        }

        @keyframes sparkFly1 {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            50% { transform: translate(-30px, -30px) scale(1); opacity: 0.8; }
            100% { transform: translate(-50px, -50px) scale(0); opacity: 0; }
        }

        @keyframes sparkFly2 {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            50% { transform: translate(30px, -30px) scale(1); opacity: 0.8; }
            100% { transform: translate(50px, -50px) scale(0); opacity: 0; }
        }

        @keyframes sparkFly3 {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            50% { transform: translate(-30px, 30px) scale(1); opacity: 0.8; }
            100% { transform: translate(-50px, 50px) scale(0); opacity: 0; }
        }

        @keyframes sparkFly4 {
            0% { transform: translate(0, 0) scale(0); opacity: 1; }
            50% { transform: translate(30px, 30px) scale(1); opacity: 0.8; }
            100% { transform: translate(50px, 50px) scale(0); opacity: 0; }
        }

        /* Glowing frame around winning symbols (like the photo) */
        .winning-frame {
            position: absolute;
            top: -8px;
            left: -8px;
            right: -8px;
            bottom: -8px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 20;
            border: 4px solid rgba(255,215,0,0.9);
            box-shadow: 0 0 30px rgba(255,215,0,0.9), 0 0 60px rgba(255,215,0,0.5), inset 0 0 18px rgba(255, 240, 180, 0.25);
            transform: scale(1);
        }

        @keyframes winningFramePulse {
            0% { transform: scale(1); filter: drop-shadow(0 0 6px rgba(255,215,0,0.6)); }
            50% { transform: scale(1.03); filter: drop-shadow(0 0 18px rgba(255,215,0,0.95)); }
            100% { transform: scale(1); filter: drop-shadow(0 0 6px rgba(255,215,0,0.6)); }
        }

        /* Shard fragments used for explosion */
        .shard {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 18px;
            background: linear-gradient(180deg, #FFF7D6, #FFD700 60%, #FFB84D);
            box-shadow: 0 0 8px rgba(255,215,0,0.9);
            transform-origin: center;
            pointer-events: none;
            z-index: 30;
            border-radius: 2px;
        }

        @keyframes shardFly {
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: translate(var(--tx,0px), var(--ty,0px)) scale(0.2) rotate(var(--rot,360deg)); opacity: 0; }
        }

        /* Fullscreen lightning overlay for mega wins */
        .fullscreen-lightning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.0);
            z-index: 99999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 200ms linear;
        }

        .fullscreen-lightning.active {
            opacity: 1;
        }

        .fullscreen-lightning svg {
            width: 120vw;
            height: 120vh;
            max-height: 120vh;
            object-fit: cover;
            transform: translateX(-10vw);
            overflow: visible;
        }

        .fullscreen-lightning .light-flash {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.3) 20%, rgba(255,255,255,0) 40%);
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 120ms linear;
            pointer-events: none;
        }

        .fullscreen-lightning.active .light-flash {
            opacity: 1;
            transition: opacity 120ms linear;
        }

        /* Previous Win Block Animations - removed to prevent jumping */

        /* Big Win Celebration Board */
        /* Big win board removed */

        /* Winning line connection effect */
        .winning-line {
            position: absolute;
            background: linear-gradient(90deg, 
                transparent 0%, 
                #ffd700 20%, 
                #fff700 50%, 
                #ffd700 80%, 
                transparent 100%);
            height: 4px;
            z-index: 8;
            animation: lineGlow 0.8s ease-in-out;
            border-radius: 2px;
            box-shadow: 
                0 0 10px #ffd700,
                0 0 20px #ffd700;
        }

        @keyframes lineGlow {
            0%, 100% { 
                opacity: 0;
                transform: scaleX(0);
            }
            50% { 
                opacity: 1;
                transform: scaleX(1);
            }
        }

        /* Small Win - Gentle glow and soft pulse */
        .symbol-item.small-win {
            position: relative;
            z-index: 10;
        }



        /* Medium Win - Noticeable bounce and glow */
        .symbol-item.medium-win {
            position: relative;
            z-index: 10;
        }



        /* Big Win - Dynamic animation with strong effects */
        .symbol-item.big-win {
            position: relative;
            z-index: 10;
        }



        /* Mega Win - Celebration animation */
        .symbol-item.mega-win {
            position: relative;
            z-index: 10;
        }











        /* Win Classes */
        .symbol-item.small-win {
            position: relative;
            z-index: 10;
        }

        .symbol-item.medium-win {
            position: relative;
            z-index: 10;
        }

        .symbol-item.big-win {
            position: relative;
            z-index: 10;
        }

        .symbol-item.mega-win {
            position: relative;
            z-index: 10;
        }

        /* Winning symbol glow effect like in original Gates of Olympus */
        .symbol-item.winning {
            position: relative;
            z-index: 10;
            overflow: visible;
        }

        /* Animation for inactive symbols */





        /* Lightning effect container */
        .lightning-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            overflow: hidden;
        }

        /* Zeus lightning overlay fading animation */
        .zeus-lightning.fading {
            animation: lightningFadeOut 0.3s ease-out forwards;
        }

        /* Slot lightning overlay fading animation */
        .slot-lightning.fading {
            animation: lightningFadeOut 0.3s ease-out forwards;
        }

        @keyframes lightningFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #fff 0%, #87ceeb 50%, transparent 100%);
            border-radius: 50%;
        }

        @keyframes sparkFly {
            0% { 
                opacity: 1; 
                transform: scale(1) rotate(0deg); 
            }
            100% { 
                opacity: 0; 
                transform: scale(0.2) rotate(360deg) translate(var(--spark-x), var(--spark-y)); 
            }
        }

        /* Cinematic Canvas */
        .cinematic-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .cinematic-canvas.active {
            opacity: 1;
        }

        /* Screen shake for explosive wins */
        .screen-shake {
            animation: screenShakeAnim 520ms cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes screenShakeAnim {
            0% { transform: translateX(0) translateY(0); }
            10% { transform: translateX(-10px) translateY(0); }
            30% { transform: translateX(8px) translateY(-4px); }
            50% { transform: translateX(-6px) translateY(3px); }
            70% { transform: translateX(4px) translateY(-2px); }
            90% { transform: translateX(-2px) translateY(1px); }
            100% { transform: translateX(0) translateY(0); }
        }

        /* ----- Added slot animation styles (Spin Start, Motion Blur, Fall, Highlight) ----- */
        /* Spin start flash */
        .spin-start-flash {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 30%, rgba(255,255,255,0.18), rgba(255,215,0,0.08) 30%, transparent 60%);
            pointer-events: none;
            z-index: 9996;
            opacity: 0;
            animation: spinStartFlashAnim 420ms ease-out forwards;
        }

        @keyframes spinStartFlashAnim {
            0% { opacity: 0; transform: scale(0.98); }
            40% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0; transform: scale(1); }
        }

        /* Motion blur for spinning symbols (vertical feel) - softened to be less noticeable */
        .symbols-column.spinning img,
        .symbols-strip.spinning .symbol-img {
            filter: blur(1px);
            transition: filter 120ms linear;
            will-change: filter, transform;
        }

        /* Darken top of reels to give depth */
        .slot-area.top-darkened::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 18%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.18), rgba(0,0,0,0));
            pointer-events: none;
            z-index: 8;
            opacity: 1;
        }

        /* Reel pull-down effect (ease-in) */
        .reel.pull-down {
            transform-origin: top center;
            animation: reelPullDown 420ms cubic-bezier(0.4,0,1,1) forwards;
        }

        @keyframes reelPullDown {
            0% { transform: translateY(-6px) scaleY(0.998); }
            100% { transform: translateY(0) scaleY(1); }
        }

        /* Falling / cascade animation */
        .symbol-item.falling {
            transform: translateY(-100px);
            animation: fallIn 420ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        @keyframes fallIn {
            0% { transform: translateY(-140px); opacity: 0; }
            70% { transform: translateY(8px); opacity: 1; }
            100% { transform: translateY(0px); }
        }

        /* Small bounce at stop */
        .reel .symbols-column.stop-bounce {
            animation: reelStopBounce 420ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        @keyframes reelStopBounce {
            0% { transform: translateY(var(--stop-start,0%)); }
            70% { transform: translateY(calc(var(--stop-start,0%) - 6px)); }
            100% { transform: translateY(var(--stop-start,0%)); }
        }

        /* Winner highlight: gold aura + pulse + slight scale */
        .symbol-item.winning.golden-highlight img {
            transform-origin: center center;
            animation: winningPulse 900ms ease-in-out forwards;
            filter: drop-shadow(0 0 10px rgba(255,215,0,0.9));
        }

        @keyframes winningPulse {
            0% { transform: scale(1); filter: drop-shadow(0 0 8px rgba(255,215,0,0.6)); }
            40% { transform: scale(1.12); filter: drop-shadow(0 0 24px rgba(255,240,160,0.95)); }
            100% { transform: scale(1); filter: drop-shadow(0 0 12px rgba(255,215,0,0.8)); }
        }

        /* Win counter overlay (temporary big number) */
        .win-counter-overlay {
            position: absolute;
            left: 50%;
            top: 26%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 40px;
            font-weight: 800;
            text-shadow: 0 0 20px #FFD700, 0 0 40px #fff;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 180ms ease;
        }

        /* Flying coin animation for nicer crediting */
        .coin-fly-container {
            position: absolute;
            pointer-events: none;
            z-index: 10050;
            will-change: transform, opacity;
        }

        /* Flying coins animation removed */




    </style>
</head>
<body>
    <div class="game-container">
        <!-- Canvas for cinematic effects -->
        <canvas id="cinematic-canvas" class="cinematic-canvas"></canvas>

        <!-- Zeus -->
        <div class="zeus-container">
            <img id="zeus-img" class="zeus-img" src="assets/animations/zeus_pose_all-zeus_summon_titan_symbol.gif" alt="Zeus">
        </div>

        <!-- Main Win Display Board -->
        <div id="main-win-board" class="main-win-board">
            <div class="win-board-content">
                <div class="win-board-label">TOTAL WIN</div>
                <div id="total-win-amount" class="total-win-amount">0</div>
            </div>
        </div>

        <!-- Slot Machine -->
        <div class="slot-area" id="slot-area">
            <!-- 5 reels will be generated here -->
        </div>

        <!-- Previous Win Display removed -->

        <!-- Big Win Celebration Board removed -->

        <!-- UI -->
        <div class="ui-container">
            <div id="title" class="title">Battle for the Power of Olympus</div>
            <div id="subtitle" class="subtitle">Press SPIN and try your luck</div>
            <div id="win-status" class="win-status"></div>
            <button id="spin-btn" class="spin-btn">SPIN</button>
        </div>

    </div>

    <!-- Audio (hidden) -->
    <audio id="click-sound" src="assets/audio/Click.mp3" preload="auto"></audio>
    <audio id="spin-sound" src="assets/audio/cash-counter-machine-count-50-bills-1.mp3" preload="auto"></audio>
    <audio id="win-sound" src="assets/audio/Money Win 3 - 02.mp3" preload="auto"></audio>
    <audio id="big-win-sound" src="assets/audio/Money Win 3 - 02.mp3" preload="auto"></audio>
    <audio id="mega-win-sound" src="assets/audio/Slot Win 6.mp3" preload="auto"></audio>
    <audio id="ice-win-6" src="assets/audio/Ice Win 6.mp3" preload="auto"></audio>
    <audio id="coin-sound" src="assets/audio/Win Swish 1.mp3" preload="auto"></audio>

    <script>
        // Configuration
        const symbols = [
            { id: "hv1", src: "assets/png/symbols/gool_hv1.png" },
            { id: "hv2", src: "assets/png/symbols/gool_hv_2.png" },
            { id: "hv3", src: "assets/png/symbols/gool_hv3.png" },
            { id: "hv4", src: "assets/png/symbols/gool_hv4.png" },
            { id: "lv1", src: "assets/png/symbols/gool_lv_1_orange.png" },
            { id: "lv2", src: "assets/png/symbols/gool_lv_2_purple.png" },
            { id: "lv3", src: "assets/png/symbols/gool_lv_3_yellow.png" },
            { id: "lv4", src: "assets/png/symbols/gool_lv_4_green.png" },
            { id: "lv5", src: "assets/png/symbols/gool_lv_5_blue.png" },
            { id: "wild", src: "assets/png/symbols/gool_wild_idle.png" },
            { id: "scatter", src: "assets/png/symbols/gool_scatter_win.png" }
        ];

    // Total symbols used during a spin sequence (controls how many items are scrolled)
    // Increase this to lengthen internal spin distance (more apparent rotations)
    const TOTAL_SPIN_SYMBOLS = 36;

        const combinations = [
            { id: "small_win_lv1", symbolId: "lv1", count: 4, winLevel: "small" },
            { id: "small_win_lv2", symbolId: "lv2", count: 4, winLevel: "small" },
            { id: "small_win_lv3", symbolId: "lv3", count: 5, winLevel: "small" },
            { id: "medium_win_lv4", symbolId: "lv4", count: 6, winLevel: "medium" },
            { id: "medium_win_lv5", symbolId: "lv5", count: 7, winLevel: "medium" },
            { id: "big_win_hv1", symbolId: "hv1", count: 8, winLevel: "big" },
            { id: "big_win_hv2", symbolId: "hv2", count: 9, winLevel: "big" },
            { id: "mega_win_hv3", symbolId: "hv3", count: 12, winLevel: "mega" },
            { id: "mega_win_hv4", symbolId: "hv4", count: 15, winLevel: "mega" }
        ];

        // Gameplay modifiers
        const smallWinPenaltyPercent = 20; // percent taken from small wins (default 20%)

        // Smooth Zeus movement controller (2D smooth movement: up/down/left/right)
        class SmoothZeus {
            constructor() {
                this.el = document.querySelector('.zeus-container');
                this.img = this.el.querySelector('#zeus-img');
                this.game = document.querySelector('.game-container');
                this.running = false;
                this.pos = { x: 0, y: 0 };
                this.target = { x: 0, y: 0 };
                this.currentAnchor = 'right'; // start on right side by default
                this.speed = 0.08; // smoothing factor (0..1)
                this._targetTimer = null;
                this.initStyles();
                this._updateAnchors();
                this.setToAnchor(this.currentAnchor, true);
            }

            initStyles() {
                // Ensure container is positioned absolutely relative to game container
                this.el.style.position = 'absolute';
                this.el.style.left = '0';
                this.el.style.top = '0';
                this.el.style.pointerEvents = 'none';
                this.el.style.zIndex = '50';
                // keep image rendering smooth
                if (this.img) this.img.style.willChange = 'transform';
            }

            setToCenter() {
                const r = this.game.getBoundingClientRect();
                this.pos.x = Math.round(r.width / 2);
                this.pos.y = Math.round(r.height / 2);
                this.target = { ...this.pos };
                this.apply();
            }

            apply() {
                // Use translate + translate(-50%,-50%) so the sprite is centered
                // Apply subtle hover offset if enabled (vertical oscillation)
                let hoverOffset = 0;
                if (this.hoverEnabled) {
                    const t = (performance.now() - this.hoverStart) * 0.001; // seconds
                    hoverOffset = Math.sin(t * this.hoverFrequency) * this.hoverAmplitude;
                }
                // Global vertical nudge to lift Zeus slightly (10px up)
                const verticalNudge = -40;
                this.el.style.transform = `translate(${this.pos.x}px, ${this.pos.y + hoverOffset + verticalNudge}px) translate(-50%, -50%)`;
            }

            setToAnchor(name, instant = false) {
                this._updateAnchors();
                if (!this.anchors[name]) return;
                const a = this.anchors[name];
                this.currentAnchor = name;
                if (instant) {
                    this.pos.x = Math.round(a.x);
                    this.pos.y = Math.round(a.y);
                    this.target = { ...this.pos };
                    this.apply();
                } else {
                    this.target = { x: Math.round(a.x), y: Math.round(a.y) };
                }
            }

            start() {
                if (this.running) return;
                this.running = true;
                this._loop();
            }

            // Start a gentle hovering motion (vertical oscillation)
            startHover(amplitude = 6, frequency = 1.5) {
                this.hoverEnabled = true;
                this.hoverAmplitude = amplitude; // px
                // frequency is in cycles per second
                this.hoverFrequency = frequency * Math.PI * 2; // convert to rad/sec multiplier
                this.hoverStart = performance.now();
            }

            // Stop the hovering motion
            stopHover() {
                this.hoverEnabled = false;
            }

            stop() {
                this.running = false;
                if (this._targetTimer) clearTimeout(this._targetTimer);
            }

            _loop() {
                if (!this.running) return;
                // Smoothly move towards the target
                const dx = this.target.x - this.pos.x;
                const dy = this.target.y - this.pos.y;
                // lerp
                this.pos.x += dx * this.speed;
                this.pos.y += dy * this.speed;
                this.apply();
                requestAnimationFrame(() => this._loop());
            }

            _scheduleNextTarget() {
                const pick = () => {
                    const r = this.game.getBoundingClientRect();
                    // Recompute anchors if needed
                    this._updateAnchors();
                    const names = Object.keys(this.anchors);
                    // pick an anchor different from current target more often
                    let attempts = 0;
                    let name;
                    do {
                        name = names[Math.floor(Math.random() * names.length)];
                        attempts++;
                    } while (this.target && this.anchors[name] && Math.hypot(this.target.x - this.anchors[name].x, this.target.y - this.anchors[name].y) < 40 && attempts < 6);
                    this.target = { x: Math.round(this.anchors[name].x), y: Math.round(this.anchors[name].y) };
                    // schedule next change in 2.5-5.0s for slow smooth movement
                    this._targetTimer = setTimeout(pick, 2500 + Math.random() * 2500);
                };
                pick();
            }

            _updateAnchors() {
                const r = this.game.getBoundingClientRect();
                this.anchors = {
                    left: { x: r.width * 0.15, y: r.height * 0.12 },
                    right: { x: r.width * 0.85, y: r.height * 0.12 },
                    top: { x: r.width * 0.5, y: r.height * 0.12 },
                    bottom: { x: r.width * 0.5, y: r.height * 0.88 },
                    center: { x: r.width * 0.5, y: r.height * 0.5 }
                };
            }

            // Keep compatibility methods used elsewhere
            performRandomMovement() {
                this._updateAnchors();
                const names = Object.keys(this.anchors);
                const choice = names[Math.floor(Math.random() * names.length)];
                this.target = { x: Math.round(this.anchors[choice].x), y: Math.round(this.anchors[choice].y) };
            }

            performSequentialMovement() {
                // Called during spins by legacy code: keep Zeus in place but nudge slightly
                this.onSpin(false);
            }

            moveToSide(side) {
                this._updateAnchors();
                if (this.anchors[side]) {
                    this.target = { x: Math.round(this.anchors[side].x), y: Math.round(this.anchors[side].y) };
                    this.preferredAnchor = side;
                    this.currentAnchor = side;
                }
            }

            onSpin(moveSide = true) {
                // On spin: either small visual nudge or toggle side between left/right
                if (!this.img) return;
                // small nudge animation
                this.img.animate([
                    { transform: 'translateY(0) scale(1)' },
                    { transform: 'translateY(-6px) scale(1.04)' },
                    { transform: 'translateY(0) scale(1)' }
                ], { duration: 380, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });

                if (moveSide) {
                    // toggle between left and right anchors
                    this._updateAnchors();
                    const left = 'left';
                    const right = 'right';
                    const next = (this.currentAnchor === left) ? right : left;
                    this.moveToSide(next);
                }
            }

            reactToWin(winLevel) {
                this._updateAnchors();
                // Move Zeus to center for all win levels with cinematic timing
                this.moveToSide('center');
            }
        }

        // Initialize Zeus movement controller
        let zeusController = new SmoothZeus();

        // Ensure Zeus starts centered and with a gentle float awaiting user interaction
        try {
            const _zc = document.querySelector('.zeus-container');
            if (_zc) {
                _zc.classList.add('floating-center');
            }
            if (zeusController && typeof zeusController.setToAnchor === 'function') {
                zeusController.setToAnchor('center', true);
                if (typeof zeusController.start === 'function') zeusController.start();
                if (typeof zeusController.startHover === 'function') zeusController.startHover(4, 1.2);
            }
        } catch (e) { console.log('zeus init error', e); }

        let currentState = 'welcome';
        let isSpinning = false;
        let totalWinAmount = 0; // Track total winnings
        let spinCount = 0;
        const predefinedOutcomes = ['win', 'bigger_win', 'fake_lose', 'mega_win'];
        // When true, only play the explosion sound ('ice-win-6') and suppress other sounds
        let explosionOnlyMode = false;
        // Percentage of total to deduct on a losing spin (default = 2%)
        let LOSS_PERCENT = 2;

        // Apply loss deduction: subtract a percentage of the current total and show overlay
        function applyLossPercentage() {
            try {
                if (!totalWinAmount || totalWinAmount <= 0) return 0;
                const deduction = Math.max(1, Math.floor(totalWinAmount * (LOSS_PERCENT / 100)));
                totalWinAmount = Math.max(0, totalWinAmount - deduction);
                if (totalWinAmountEl) totalWinAmountEl.textContent = totalWinAmount;

                // Show red overlay indicating loss
                const container = document.querySelector('.game-container');
                const overlay = document.createElement('div');
                overlay.className = 'loss-overlay';
                overlay.textContent = `-${deduction}`;
                overlay.style.position = 'absolute';
                // Position above slot-area center
                const slotRect = slotArea.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                const left = slotRect.left - gameRect.left + slotRect.width / 2;
                const top = slotRect.top - gameRect.top - 48;
                overlay.style.left = left + 'px';
                overlay.style.top = top + 'px';
                overlay.style.transform = 'translateX(-50%)';
                overlay.style.fontSize = '28px';
                overlay.style.color = '#ff4d4d';
                overlay.style.background = 'rgba(0,0,0,0.45)';
                overlay.style.padding = '6px 10px';
                overlay.style.borderRadius = '6px';
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 220ms ease, transform 420ms ease';
                overlay.style.zIndex = '10005';
                container.appendChild(overlay);
                requestAnimationFrame(() => {
                    overlay.style.opacity = '1';
                    overlay.style.transform = 'translateX(-50%) translateY(-6px)';
                });

                setTimeout(() => { overlay.style.opacity = '0'; overlay.style.transform = 'translateX(-50%) translateY(-18px)'; }, 900);
                setTimeout(() => { try { overlay.remove(); } catch(e){} }, 1300);

                // Optionally play a loss sound if available
                try { playSound('loss-sound'); } catch(e) {}

                return deduction;
            } catch (e) { console.log('applyLossPercentage error', e); return 0; }
        }

        // DOM Elements
        const gameContainer = document.querySelector('.game-container');
        const slotArea = document.getElementById('slot-area');
        const zeusImg = document.getElementById('zeus-img');
        const title = document.getElementById('title');
        const subtitle = document.getElementById('subtitle');
        const winStatus = document.getElementById('win-status');
        const spinBtn = document.getElementById('spin-btn');
        const totalWinAmountEl = document.getElementById('total-win-amount');
        const previousWinBlock = document.getElementById('previous-win-block');
        const previousWinAmountEl = document.getElementById('previous-win-amount');

        // Helper functions
        function generateRandomGrid() {
            // Produce a grid in column-major format: 6 columns, each with 6 visible symbols
            const grid = [];
            for (let col = 0; col < 6; col++) {
                const column = [];
                for (let row = 0; row < 6; row++) {
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    column.push(randomSymbol.id);
                }
                grid.push(column);
            }
            return grid;
        }

        // Normalize incoming grids (support both row-major and column-major shapes)
        function normalizeGrid(inputGrid) {
            if (!inputGrid) return generateRandomGrid();

            // If already column-major 6x6
            if (inputGrid.length === 6 && inputGrid[0] && inputGrid[0].length === 6) return inputGrid;

            // If input is row-major 5x6 (5 rows, 6 columns) -> transpose to 6 columns x 5 rows and pad to 6 rows
            if (inputGrid.length === 5 && inputGrid[0] && inputGrid[0].length === 6) {
                const cols = [];
                for (let c = 0; c < 6; c++) {
                    cols[c] = [];
                    for (let r = 0; r < 5; r++) {
                        cols[c].push(inputGrid[r][c]);
                    }
                    while (cols[c].length < 6) {
                        cols[c].push(symbols[Math.floor(Math.random() * symbols.length)].id);
                    }
                }
                return cols;
            }

            // If input is 6 columns x 5 rows, pad each column to 6
            if (inputGrid.length === 6 && inputGrid[0] && inputGrid[0].length === 5) {
                return inputGrid.map(col => {
                    const copy = col.slice();
                    while (copy.length < 6) copy.push(symbols[Math.floor(Math.random() * symbols.length)].id);
                    return copy;
                });
            }

            // Unknown shape: try to coerce into 6x6 by filling with random symbols
            try {
                const coerced = [];
                for (let c = 0; c < 6; c++) {
                    coerced[c] = [];
                    for (let r = 0; r < 6; r++) {
                        coerced[c].push((inputGrid[c] && inputGrid[c][r]) ? inputGrid[c][r] : symbols[Math.floor(Math.random() * symbols.length)].id);
                    }
                }
                return coerced;
            } catch (e) {
                return generateRandomGrid();
            }
        }

        function generateGridFromCombination(combination) {
            // Ensure grid is column-major 6x6
            const grid = generateRandomGrid();
            const { symbolId, count } = combination;

            // Collect positions for 6x6 grid
            const positions = [];
            for (let col = 0; col < 6; col++) {
                for (let row = 0; row < 6; row++) {
                    positions.push({ col, row });
                }
            }

            // Shuffle positions to place winning symbols randomly
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Place winning symbols
            for (let i = 0; i < count; i++) {
                if (i < positions.length) {
                    const { col, row } = positions[i];
                    grid[col][row] = symbolId;
                }
            }

            return grid;
        }

        function evaluateGrid(grid) {
            const symbolCounts = new Map();
            const symbolPositions = new Map();

            for (let col = 0; col < grid.length; col++) {
                for (let row = 0; row < grid[col].length; row++) {
                    const symbolId = grid[col][row];
                    if (!symbolCounts.has(symbolId)) {
                        symbolCounts.set(symbolId, 0);
                        symbolPositions.set(symbolId, []);
                    }
                    symbolCounts.set(symbolId, symbolCounts.get(symbolId) + 1);
                    symbolPositions.get(symbolId).push([col, row]);
                }
            }

            let allWinPositions = [];
            let winningSymbolId = null;
            let maxCount = 0;

            for (const [symbolId, count] of symbolCounts.entries()) {
                if (count > maxCount) {
                    maxCount = count;
                    winningSymbolId = symbolId;
                }
            }

            // A win requires at least 4 identical symbols anywhere on the grid.
            if (maxCount >= 4) {
                allWinPositions = symbolPositions.get(winningSymbolId);
            }
            
            return {
                winPositions: allWinPositions,
                grid: grid
            };
        }

        function getSymbolSrc(id) {
            const symbol = symbols.find(s => s.id === id);
            return symbol ? symbol.src : symbols[0].src;
        }

        function playSound(id) {
            try {
                // If explosionOnlyMode is active, only allow the ice-win sound to play
                if (typeof explosionOnlyMode !== 'undefined' && explosionOnlyMode && id !== 'ice-win-6') return;
                const audio = document.getElementById(id);
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => console.log('Audio play failed:', e));
                }
            } catch (e) {
                console.log('Sound error:', e);
            }
        }

        function createWinningLines(winPositions) {
            const container = document.querySelector('.slot-area');
            const reels = container.querySelectorAll('.reel');
            
            // Group positions by rows to create horizontal lines
            const rowGroups = {};
            winPositions.forEach(([col, row]) => {
                if (!rowGroups[row]) rowGroups[row] = [];
                rowGroups[row].push(col);
            });

            Object.keys(rowGroups).forEach(row => {
                const cols = rowGroups[row].sort((a, b) => a - b);
                if (cols.length > 1) {
                    // Create line from first to last symbol in this row
                    const firstReel = reels[cols[0]];
                    const lastReel = reels[cols[cols.length - 1]];
                    
                    const firstRect = firstReel.getBoundingClientRect();
                    const lastRect = lastReel.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    const line = document.createElement('div');
                    line.className = 'winning-line';
                    
                    const symbolHeight = firstRect.height / 6; // 6 symbols per reel
                    const rowOffset = parseInt(row) * symbolHeight + symbolHeight / 2;
                    
                    line.style.left = (firstRect.left - containerRect.left + firstRect.width * 0.1) + 'px';
                    line.style.top = (firstRect.top - containerRect.top + rowOffset) + 'px';
                    line.style.width = (lastRect.left - firstRect.left + lastRect.width * 0.8) + 'px';
                    
                    container.appendChild(line);
                    
                    // Remove line after animation
                    setTimeout(() => {
                        if (line.parentNode) {
                            line.parentNode.removeChild(line);
                        }
                    }, 1000);
                }
            });
        }

        function createSparks(symbolElement) {
            // Create sparks container relative to the symbol
            const sparksContainer = document.createElement('div');
            sparksContainer.className = 'sparks-container';
            sparksContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 250;
                overflow: visible;
            `;
            
            // Enhanced spark creation with explosion effects
            for (let i = 0; i < 12; i++) {
                const spark = document.createElement('div');
                spark.className = 'spark explosion-spark';
                
                spark.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: ${Math.random() * 4 + 3}px;
                    height: ${Math.random() * 4 + 3}px;
                    background: ${i % 3 === 0 ? '#FFD700' : i % 3 === 1 ? '#FFF700' : '#FFFFFF'};
                    border-radius: 50%;
                    pointer-events: none;
                    transform-origin: center;
                    box-shadow: 0 0 ${Math.random() * 10 + 8}px currentColor;
                `;
                
                // Random direction and distance
                const angle = (Math.PI * 2 * i) / 12 + Math.random() * 0.3;
                const distance = 30 + Math.random() * 40;
                const deltaX = Math.cos(angle) * distance;
                const deltaY = Math.sin(angle) * distance;
                
                sparksContainer.appendChild(spark);
                
                // Animate spark with Web Animations API
                spark.animate([
                    { 
                        transform: 'translate(-50%, -50%) scale(0) rotate(0deg)', 
                        opacity: 1 
                    },
                    { 
                        transform: `translate(-50%, -50%) translate(${deltaX * 0.5}px, ${deltaY * 0.5}px) scale(1.3) rotate(${Math.random() * 180}deg)`, 
                        opacity: 0.9,
                        offset: 0.3 
                    },
                    { 
                        transform: `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px) scale(1) rotate(${Math.random() * 360}deg)`, 
                        opacity: 0.6,
                        offset: 0.7 
                    },
                    { 
                        transform: `translate(-50%, -50%) translate(${deltaX * 1.2}px, ${deltaY * 1.2}px) scale(0) rotate(${Math.random() * 540}deg)`, 
                        opacity: 0 
                    }
                ], {
                    duration: 800 + Math.random() * 400,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                });
            }
            
            // Add sparks container to symbol
            symbolElement.appendChild(sparksContainer);
            
            // Remove sparks after animation
            setTimeout(() => {
                if (sparksContainer.parentNode) {
                    sparksContainer.remove();
                }
            }, 1300);
        }

        // Confetti generator: creates small colorful rectangles that fly out and fade
        function createConfettiAt(targetElement, count = 12) {
            try {
                const gameRect = gameContainer.getBoundingClientRect();
                const rect = targetElement.getBoundingClientRect();
                const container = document.createElement('div');
                container.style.position = 'absolute';
                container.style.left = (rect.left - gameRect.left) + 'px';
                container.style.top = (rect.top - gameRect.top) + 'px';
                container.style.width = rect.width + 'px';
                container.style.height = rect.height + 'px';
                container.style.pointerEvents = 'none';
                container.style.overflow = 'visible';
                container.style.zIndex = 99999;

                const colors = ['#FFD700','#FF6B35','#FF4DA6','#87CEEB','#7CFC00','#FFFFFF'];
                const maxCount = Math.min(120, Math.max(6, count));

                for (let i = 0; i < maxCount; i++) {
                    const el = document.createElement('div');
                    const w = 6 + Math.random() * 8;
                    const h = 4 + Math.random() * 6;
                    el.style.width = w + 'px';
                    el.style.height = h + 'px';
                    el.style.background = colors[Math.floor(Math.random() * colors.length)];
                    el.style.position = 'absolute';
                    el.style.left = (rect.width/2 + (Math.random() - 0.5) * rect.width * 0.6) + 'px';
                    el.style.top = (rect.height/2 + (Math.random() - 0.5) * rect.height * 0.6) + 'px';
                    el.style.opacity = '1';
                    el.style.transform = `rotate(${Math.random()*360}deg)`;
                    el.style.borderRadius = (Math.random() > 0.6 ? '2px' : '0px');
                    el.style.willChange = 'transform, opacity';
                    container.appendChild(el);

                    // Animate using Web Animations API for performance
                    const angle = (Math.random() - 0.5) * Math.PI * 2;
                    const distance = 60 + Math.random() * 160;
                    const tx = Math.cos(angle) * distance + (Math.random() - 0.5) * 40;
                    const ty = Math.sin(angle) * distance - Math.random() * 80;
                    const rot = (Math.random() - 0.5) * 720;
                    const dur = 700 + Math.random() * 800;

                    el.animate([
                        { transform: `translate(0px,0px) rotate(${Math.random()*360}deg)`, opacity: 1 },
                        { transform: `translate(${tx*0.6}px, ${ty*0.6}px) rotate(${rot*0.5}deg)`, opacity: 0.95, offset: 0.4 },
                        { transform: `translate(${tx}px, ${ty}px) rotate(${rot}deg)`, opacity: 0 }
                    ], { duration: dur, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });

                    // cleanup
                    setTimeout(() => {
                        try { if (el.parentNode) el.remove(); } catch(e){}
                    }, dur + 80);
                }

                gameContainer.appendChild(container);
                setTimeout(() => { try { container.remove(); } catch(e){} }, 2000);
            } catch (e) { console.log('createConfettiAt error', e); }
        }

        // Enhanced explosion effect for different win levels
        // Add special particle effects to winning symbols
        function addSymbolParticleEffect(element, winLevel) {
            // Don't add particles if already exists
            if (element.querySelector('.symbol-particles')) return;
            
            // Create explosion above the slot first
            createAboveSlotExplosion(element, winLevel);
            
            // Create particle container for the symbol
            const particleContainer = document.createElement('div');
            particleContainer.className = 'symbol-particles';
            particleContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
                overflow: visible;
            `;
            
            // Fewer particles to reduce lag
            let particleCount = 6;
            if (winLevel === 'medium') particleCount = 8;
            else if (winLevel === 'big') particleCount = 10;
            else if (winLevel === 'mega') particleCount = 12;
            
            // Create individual particles
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'symbol-particle';
                
                // Random particle properties
                const angle = (360 / particleCount) * i + Math.random() * 20;
                const distance = 25 + Math.random() * 25;
                const size = 2 + Math.random() * 3;
                const duration = 1.5 + Math.random() * 1;
                const delay = Math.random() * 0.3;
                
                // Particle styles
                particle.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: ${size}px;
                    height: ${size}px;
                    background: radial-gradient(circle, #FFD700, #FFF700);
                    border-radius: 50%;
                    opacity: 0;
                    transform-origin: center;
                    --angle: ${angle}deg;
                    --distance: ${distance}px;
                    box-shadow: 0 0 4px #FFD700;
                `;
                
                particleContainer.appendChild(particle);
            }
            
            element.appendChild(particleContainer);
            
            // Remove particles after animation
            setTimeout(() => {
                if (particleContainer.parentNode) {
                    particleContainer.remove();
                }
            }, 4000);
        }

        // Create explosion effect above the slot
        function createAboveSlotExplosion(element, winLevel) {
            // Create explosion container directly on the symbol
            const explosionContainer = document.createElement('div');
            explosionContainer.className = 'above-slot-explosion';
            
            explosionContainer.style.cssText = `
                position: absolute;
                top: -30px;
                left: 50%;
                transform: translateX(-50%);
                width: 60px;
                height: 60px;
                pointer-events: none;
                z-index: 200;
            `;
            
            // Create explosion particles based on win level
            let particleCount = 6;
            let particleSize = 3;
            let explosionRadius = 25;
            
            if (winLevel === 'medium') {
                particleCount = 8;
                particleSize = 4;
                explosionRadius = 30;
            } else if (winLevel === 'big') {
                particleCount = 10;
                particleSize = 5;
                explosionRadius = 35;
            } else if (winLevel === 'mega') {
                particleCount = 12;
                particleSize = 6;
                explosionRadius = 40;
            }
            
            // Create explosion particles
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                const angle = (360 / particleCount) * i + Math.random() * 30;
                const distance = explosionRadius + Math.random() * 30;
                const size = particleSize + Math.random() * 3;
                
                particle.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: ${size}px;
                    height: ${size}px;
                    background: radial-gradient(circle, #FFD700, #FF6B00);
                    border-radius: 50%;
                    animation: aboveSlotParticleFly 1.5s ease-out forwards;
                    --angle: ${angle}deg;
                    --distance: ${distance}px;
                    box-shadow: 0 0 8px #FFD700;
                `;
                
                explosionContainer.appendChild(particle);
            }
            
            // Add central burst effect
            const centralBurst = document.createElement('div');
            centralBurst.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 20px;
                height: 20px;
                background: radial-gradient(circle, #FFFFFF, #FFD700);
                border-radius: 50%;
                animation: centralBurst 1s ease-out forwards;
                box-shadow: 0 0 20px #FFD700;
            `;
            
            explosionContainer.appendChild(centralBurst);
            element.appendChild(explosionContainer);
            
            // Remove explosion after animation
            setTimeout(() => {
                if (explosionContainer.parentNode) {
                    explosionContainer.remove();
                }
            }, 1500);
        }

        function addExplosionEffect(element, winLevel) {
            if (!element) return;
            element.style.position = 'relative';
            element.style.zIndex = '15';

            // Add glowing rectangular frame around the symbol
            const frame = document.createElement('div');
            frame.className = 'winning-frame';
            element.appendChild(frame);

            // Play explosion sound for this symbol (use ice-win-6)
            try {
                const audio = document.getElementById('ice-win-6');
                if (audio) {
                    // Slightly louder for bigger wins
                    audio.volume = (winLevel === 'mega') ? 0.95 : (winLevel === 'big') ? 0.85 : 0.7;
                    audio.currentTime = 0;
                    audio.play().catch(e => {});
                }
            } catch (e) { console.log('explosion sound play error', e); }

            // Determine shard count and explosion power by win level
            let shardCount = 8;
            let shardPower = 1;
            if (winLevel === 'small') { shardCount = 8; shardPower = 0.8; }
            else if (winLevel === 'medium') { shardCount = 12; shardPower = 1.2; }
            else if (winLevel === 'big') { shardCount = 16; shardPower = 1.6; }
            else if (winLevel === 'mega') { shardCount = 22; shardPower = 2.2; }

            // Create shard fragments (rectangular) that fly out
            const shards = [];
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < shardCount; i++) {
                const shard = document.createElement('div');
                shard.className = 'shard';

                // randomize size
                const w = Math.floor(6 + Math.random() * 18);
                const h = Math.floor(10 + Math.random() * 28);
                shard.style.width = w + 'px';
                shard.style.height = h + 'px';

                // random rotation
                const rot = Math.floor(-360 + Math.random() * 720);
                shard.style.setProperty('--rot', rot + 'deg');

                // compute random target translation
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 120 * shardPower;
                const tx = Math.round(Math.cos(angle) * distance) + 'px';
                const ty = Math.round(Math.sin(angle) * distance) + 'px';
                shard.style.setProperty('--tx', tx);
                shard.style.setProperty('--ty', ty);

                // position and append
                shard.style.left = '50%';
                shard.style.top = '50%';
                shard.style.transform = 'translate(-50%, -50%) rotate(' + (Math.random()*360) + 'deg)';
                element.appendChild(shard);
                shards.push(shard);

                // animate with Web Animations API
                const dur = 700 + Math.random() * 600;
                shard.animate([
                    { transform: 'translate(-50%, -50%) scale(1) rotate(0deg)', opacity: 1 },
                    { transform: `translate(-50%, -50%) translate(calc(${tx} * 0.6), calc(${ty} * 0.6)) scale(1.2) rotate(${rot/2}deg)`, opacity: 1, offset: 0.5 },
                    { transform: `translate(-50%, -50%) translate(${tx}, ${ty}) scale(0.3) rotate(${rot}deg)`, opacity: 0 }
                ], { duration: dur, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });

                // cleanup
                setTimeout(() => { try { shard.remove(); } catch(e){} }, dur + 80);
            }

            // animate the original symbol to 'explode' and vanish
            element.classList.add('exploding');
            // Remove the image inside after short delay so shards overlap nicely
            setTimeout(() => {
                // keep the frame briefly, then remove
                try { const img = element.querySelector('img'); if (img) img.style.opacity = '0'; } catch(e){}
            }, 120);

            // Remove frame after explosion completes
            setTimeout(() => {
                try { frame.remove(); } catch(e){}
            }, 1200);

            // Optional: leave a subtle sparkle or fade placeholder
            setTimeout(() => {
                try { element.remove(); } catch(e){}
            }, 1100);
        }

        function createExplosionRing(element, colors, intensity, particleCount, ringIndex) {
            const baseRadius = 30 + (ringIndex * 20);
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                const color = colors[i % colors.length];
                const size = (Math.random() * 4 + 3) * intensity;
                
                particle.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    border-radius: 50%;
                    top: 50%;
                    left: 50%;
                    pointer-events: none;
                    z-index: ${20 + ringIndex};
                    box-shadow: 0 0 ${size * 4}px ${color};
                `;
                
                const angle = (360 / particleCount) * i + (ringIndex * 15);
                const distance = baseRadius * intensity;
                const duration = (1 + ringIndex * 0.3) * intensity;
                
                element.appendChild(particle);
                
                // Animate explosion particle
                particle.animate([
                    { 
                        transform: 'translate(-50%, -50%) scale(0)', 
                        opacity: 1 
                    },
                    { 
                        transform: `translate(calc(-50% + ${Math.cos(angle * Math.PI / 180) * distance * 0.6}px), 
                                             calc(-50% + ${Math.sin(angle * Math.PI / 180) * distance * 0.6}px)) scale(1.5)`, 
                        opacity: 0.9,
                        offset: 0.3 
                    },
                    { 
                        transform: `translate(calc(-50% + ${Math.cos(angle * Math.PI / 180) * distance}px), 
                                             calc(-50% + ${Math.sin(angle * Math.PI / 180) * distance}px)) scale(1)`, 
                        opacity: 0.7,
                        offset: 0.7 
                    },
                    { 
                        transform: `translate(calc(-50% + ${Math.cos(angle * Math.PI / 180) * distance * 1.5}px), 
                                             calc(-50% + ${Math.sin(angle * Math.PI / 180) * distance * 1.5}px)) scale(0)`, 
                        opacity: 0 
                    }
                ], {
                    duration: duration * 1000,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                });
                
                setTimeout(() => {
                    particle.remove();
                }, duration * 1000 + 100);
            }
        }

        // Fullscreen lightning playback (for Mega wins)
        function createFullScreenLightning() {
            try {
                // remove existing overlay if any
                try { if (window.megaLightningOverlay) { removeFullScreenLightning(); } } catch(e){}
                const overlay = document.createElement('div');
                overlay.className = 'fullscreen-lightning';

                // flash layer
                const flash = document.createElement('div');
                flash.className = 'light-flash';
                overlay.appendChild(flash);

                // create svg lightning group
                const xmlns = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(xmlns, 'svg');
                svg.setAttribute('viewBox', '0 0 1920 1080');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                svg.style.width = '100%';
                svg.style.height = '100%';

                // helper to build a jagged lightning path between two points
                function buildLightningPath(x1, y1, x2, y2, jagginess = 12) {
                    const segments = Math.max(6, Math.floor(jagginess + Math.random() * 8));
                    const dx = (x2 - x1) / segments;
                    const dy = (y2 - y1) / segments;
                    let path = `M ${x1} ${y1}`;
                    for (let i = 1; i < segments; i++) {
                        const nx = x1 + dx * i + (Math.random() - 0.5) * 40;
                        const ny = y1 + dy * i + (Math.random() - 0.5) * 40;
                        path += ` L ${nx} ${ny}`;
                    }
                    path += ` L ${x2} ${y2}`;
                    return path;
                }

                // create several lightning bolts
                const bolts = 3 + Math.floor(Math.random() * 3);
                for (let b = 0; b < bolts; b++) {
                    const startX = 960 + (Math.random() - 0.5) * 600; // center-ish
                    const startY = 40 + Math.random() * 120;
                    const endX = 960 + (Math.random() - 0.5) * 900;
                    const endY = 300 + Math.random() * 500;
                    const pathStr = buildLightningPath(startX, startY, endX, endY, 10 + Math.random() * 8);

                    const p = document.createElementNS(xmlns, 'path');
                    p.setAttribute('d', pathStr);
                    p.setAttribute('fill', 'none');
                    p.setAttribute('stroke-linecap', 'round');
                    p.setAttribute('stroke-linejoin', 'round');
                    p.setAttribute('stroke', '#ffffff');
                    p.setAttribute('stroke-width', 4 + Math.random() * 8);
                    p.style.filter = 'drop-shadow(0 0 18px rgba(255,255,255,0.9))';
                    p.style.opacity = '0';

                    svg.appendChild(p);

                    // animate the bolt: quick appear, flash and fade
                    const duration = 220 + Math.random() * 400;
                    const delay = Math.random() * 200;
                    setTimeout(() => {
                        // stroke glow animation using stroke-dasharray trick
                        const length = p.getTotalLength();
                        p.style.strokeDasharray = length;
                        p.style.strokeDashoffset = length;
                        p.getBoundingClientRect();
                        p.animate([
                            { strokeDashoffset: length, opacity: 0 },
                            { strokeDashoffset: length * 0.2, opacity: 1 },
                            { strokeDashoffset: 0, opacity: 1 },
                            { strokeDashoffset: -length * 0.6, opacity: 0 }
                        ], { duration: duration, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });
                        // pulse opacity for flash
                        p.animate([
                            { opacity: 0 }, { opacity: 1 }, { opacity: 0 }
                        ], { duration: duration + 120, easing: 'ease-in-out' });
                    }, delay);
                }

                overlay.appendChild(svg);
                document.body.appendChild(overlay);

                // Activate overlay flash (brief)
                requestAnimationFrame(() => overlay.classList.add('active'));

                // flash pulse timeline: a couple of bright flashes
                setTimeout(() => { flash.style.transition = 'opacity 80ms linear'; flash.style.opacity = '1'; }, 40);
                setTimeout(() => { flash.style.opacity = '0.6'; }, 120);
                setTimeout(() => { flash.style.opacity = '0'; }, 320);

                // Keep overlay until user collects bonus; store global ref for removal
                window.megaLightningOverlay = overlay;
            } catch (e) {
                console.log('Fullscreen SVG lightning failed:', e);
            }
        }

        function removeFullScreenLightning() {
            try {
                const overlay = window.megaLightningOverlay;
                if (!overlay) return;
                overlay.classList.remove('active');
                setTimeout(() => { try { overlay.remove(); } catch(e){}; }, 220);
                window.megaLightningOverlay = null;
            } catch (e) {
                console.log('removeFullScreenLightning error', e);
            }
        }

        // Zeus lightning shooting animation (for Medium wins) - Persistent looped version
        function createZeusLightning() {
            try {
                // Remove any existing Zeus lightning
                const existing = document.querySelector('.zeus-lightning');
                if (existing) existing.remove();
                
                // Get Zeus position
                const zeusContainer = document.querySelector('.zeus-container');
                if (!zeusContainer) return;
                
                const zeusRect = zeusContainer.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                
                // Zeus center position
                const zeusCenterX = zeusRect.left - gameRect.left + zeusRect.width / 2;
                const zeusCenterY = zeusRect.top - gameRect.top + zeusRect.height / 2;
                
                // Create persistent lightning overlay
                const overlay = document.createElement('div');
                overlay.className = 'zeus-lightning';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9999;
                `;
                
                // Store overlay reference for cleanup
                window.zeusLightningOverlay = overlay;
                
                // Create SVG for lightning bolts
                const xmlns = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(xmlns, 'svg');
                svg.setAttribute('viewBox', `0 0 ${gameRect.width} ${gameRect.height}`);
                svg.style.width = '100%';
                svg.style.height = '100%';
                
                overlay.appendChild(svg);
                gameContainer.appendChild(overlay);
                
                // Function to create a single lightning bolt
                function createBolt() {
                    // Target positions: spread across the slot area
                    const targetX = Math.random() * gameRect.width * 0.8 + gameRect.width * 0.1;
                    const targetY = Math.random() * gameRect.height * 0.6 + gameRect.height * 0.2;
                    
                    const pathStr = buildLightningPath(zeusCenterX, zeusCenterY, targetX, targetY, 6 + Math.random() * 4);
                    
                    const p = document.createElementNS(xmlns, 'path');
                    p.setAttribute('d', pathStr);
                    p.setAttribute('fill', 'none');
                    p.setAttribute('stroke-linecap', 'round');
                    p.setAttribute('stroke-linejoin', 'round');
                    p.setAttribute('stroke', '#ffffff');
                    p.setAttribute('stroke-width', 3 + Math.random() * 4);
                    p.style.filter = 'drop-shadow(0 0 12px rgba(255,255,255,0.9))';
                    p.style.opacity = '0';
                    
                    svg.appendChild(p);
                    
                    // Animate the bolt
                    const duration = 150 + Math.random() * 200;
                    const length = p.getTotalLength();
                    p.style.strokeDasharray = length;
                    p.style.strokeDashoffset = length;
                    
                    p.animate([
                        { strokeDashoffset: length, opacity: 0 },
                        { strokeDashoffset: length * 0.3, opacity: 1 },
                        { strokeDashoffset: 0, opacity: 1 },
                        { strokeDashoffset: -length * 0.4, opacity: 0 }
                    ], { duration: duration, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });
                    
                    p.animate([
                        { opacity: 0 }, 
                        { opacity: 1 }, 
                        { opacity: 0 }
                    ], { duration: duration + 80, easing: 'ease-in-out' });
                    
                    // Remove bolt after animation
                    setTimeout(() => {
                        if (p.parentNode) p.remove();
                    }, duration + 100);
                }
                
                // Helper to build jagged lightning path
                function buildLightningPath(x1, y1, x2, y2, jagginess = 8) {
                    const segments = Math.max(4, Math.floor(jagginess + Math.random() * 6));
                    const dx = (x2 - x1) / segments;
                    const dy = (y2 - y1) / segments;
                    let path = `M ${x1} ${y1}`;
                    for (let i = 1; i < segments; i++) {
                        const nx = x1 + dx * i + (Math.random() - 0.5) * 30;
                        const ny = y1 + dy * i + (Math.random() - 0.5) * 30;
                        path += ` L ${nx} ${ny}`;
                    }
                    path += ` L ${x2} ${y2}`;
                    return path;
                }
                
                // Create initial bolts
                for (let b = 0; b < 3; b++) {
                    setTimeout(() => createBolt(), Math.random() * 200);
                }
                
                // Continue creating bolts in a loop
                const lightningInterval = setInterval(() => {
                    if (!overlay.parentNode) {
                        clearInterval(lightningInterval);
                        return;
                    }
                    
                    // Create 1-3 bolts each interval
                    const boltCount = 1 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < boltCount; i++) {
                        setTimeout(() => createBolt(), Math.random() * 300);
                    }
                    
                    // Occasional screen flash
                    if (Math.random() < 0.3) {
                        const flash = document.createElement('div');
                        flash.className = 'lightning-flash';
                        flash.style.cssText = `
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(255, 255, 255, 0.3);
                            pointer-events: none;
                            z-index: 10000;
                        `;
                        overlay.appendChild(flash);
                        
                        setTimeout(() => { 
                            flash.style.transition = 'opacity 60ms linear'; 
                            flash.style.opacity = '0.4'; 
                        }, 20);
                        setTimeout(() => { flash.style.opacity = '0.2'; }, 80);
                        setTimeout(() => { flash.style.opacity = '0'; }, 200);
                        setTimeout(() => { if (flash.parentNode) flash.remove(); }, 300);
                    }
                }, 800 + Math.random() * 400); // Random interval between 800-1200ms
                
                // Store interval for cleanup
                overlay.lightningInterval = lightningInterval;
                
            } catch (e) {
                console.log('Zeus lightning failed:', e);
            }
        }

        // Function to stop Zeus lightning
        function stopZeusLightning() {
            try {
                const overlay = window.zeusLightningOverlay;
                if (!overlay) return;
                
                if (overlay.lightningInterval) {
                    clearInterval(overlay.lightningInterval);
                }
                
                overlay.classList.add('fading');
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.remove();
                    }
                }, 300);
                window.zeusLightningOverlay = null;
            } catch (e) {
                console.log('stopZeusLightning error', e);
            }
        }

        // Create lightning animation in slot area for wins
        function createSlotAreaLightning(winLevel) {
            try {
                // Remove any existing slot lightning
                const existing = document.querySelector('.slot-lightning');
                if (existing) existing.remove();
                
                const slotArea = document.querySelector('.slot-area');
                if (!slotArea) return;
                
                const slotRect = slotArea.getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                
                // Create lightning overlay for slot area
                const overlay = document.createElement('div');
                overlay.className = 'slot-lightning';
                overlay.style.cssText = `
                    position: absolute;
                    top: ${slotRect.top - gameRect.top}px;
                    left: ${slotRect.left - gameRect.left}px;
                    width: ${slotRect.width}px;
                    height: ${slotRect.height}px;
                    pointer-events: none;
                    z-index: 9998;
                `;
                
                // Store overlay reference for cleanup
                window.slotLightningOverlay = overlay;
                
                // Create SVG for lightning bolts
                const xmlns = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(xmlns, 'svg');
                svg.setAttribute('viewBox', `0 0 ${slotRect.width} ${slotRect.height}`);
                svg.style.width = '100%';
                svg.style.height = '100%';
                
                overlay.appendChild(svg);
                gameContainer.appendChild(overlay);
                
                // Function to create a single lightning bolt
                function createBolt() {
                    // Target positions within slot area
                    const targetX = Math.random() * slotRect.width;
                    const targetY = Math.random() * slotRect.height;
                    
                    // Start from top or sides
                    const startSide = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                    let startX, startY;
                    
                    switch(startSide) {
                        case 0: // top
                            startX = Math.random() * slotRect.width;
                            startY = -20;
                            break;
                        case 1: // right
                            startX = slotRect.width + 20;
                            startY = Math.random() * slotRect.height;
                            break;
                        case 2: // bottom
                            startX = Math.random() * slotRect.width;
                            startY = slotRect.height + 20;
                            break;
                        case 3: // left
                            startX = -20;
                            startY = Math.random() * slotRect.height;
                            break;
                    }
                    
                    const pathStr = buildLightningPath(startX, startY, targetX, targetY, 4 + Math.random() * 3);
                    
                    const p = document.createElementNS(xmlns, 'path');
                    p.setAttribute('d', pathStr);
                    p.setAttribute('fill', 'none');
                    p.setAttribute('stroke-linecap', 'round');
                    p.setAttribute('stroke-linejoin', 'round');
                    p.setAttribute('stroke', '#ffffff');
                    p.setAttribute('stroke-width', 2 + Math.random() * 3);
                    p.style.filter = 'drop-shadow(0 0 8px rgba(255,255,255,0.9))';
                    p.style.opacity = '0';
                    
                    svg.appendChild(p);
                    
                    // Animate the bolt
                    const duration = 200 + Math.random() * 300;
                    const length = p.getTotalLength();
                    p.style.strokeDasharray = length;
                    p.style.strokeDashoffset = length;
                    
                    p.animate([
                        { strokeDashoffset: length, opacity: 0 },
                        { strokeDashoffset: length * 0.3, opacity: 1 },
                        { strokeDashoffset: 0, opacity: 1 },
                        { strokeDashoffset: -length * 0.4, opacity: 0 }
                    ], { duration: duration, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });
                    
                    p.animate([
                        { opacity: 0 }, 
                        { opacity: 1 }, 
                        { opacity: 0 }
                    ], { duration: duration + 50, easing: 'ease-in-out' });
                    
                    // Remove bolt after animation
                    setTimeout(() => {
                        if (p.parentNode) p.remove();
                    }, duration + 100);
                }
                
                // Helper to build jagged lightning path
                function buildLightningPath(x1, y1, x2, y2, jagginess = 6) {
                    const segments = Math.max(3, Math.floor(jagginess + Math.random() * 4));
                    const dx = (x2 - x1) / segments;
                    const dy = (y2 - y1) / segments;
                    let path = `M ${x1} ${y1}`;
                    for (let i = 1; i < segments; i++) {
                        const nx = x1 + dx * i + (Math.random() - 0.5) * 25;
                        const ny = y1 + dy * i + (Math.random() - 0.5) * 25;
                        path += ` L ${nx} ${ny}`;
                    }
                    path += ` L ${x2} ${y2}`;
                    return path;
                }
                
                // Create initial bolts based on win level
                let boltCount = 3;
                if (winLevel === 'medium') boltCount = 5;
                else if (winLevel === 'big') boltCount = 7;
                else if (winLevel === 'mega') boltCount = 10;
                
                for (let b = 0; b < boltCount; b++) {
                    setTimeout(() => createBolt(), Math.random() * 200);
                }
                
                // Continue creating bolts in a loop for bigger wins
                if (winLevel !== 'small') {
                    const lightningInterval = setInterval(() => {
                        if (!overlay.parentNode) {
                            clearInterval(lightningInterval);
                            return;
                        }
                        
                        // Create 1-2 bolts each interval
                        const intervalBoltCount = 1 + Math.floor(Math.random() * 2);
                        for (let i = 0; i < intervalBoltCount; i++) {
                            setTimeout(() => createBolt(), Math.random() * 150);
                        }
                    }, 400 + Math.random() * 300); // Random interval between 400-700ms
                    
                    // Store interval for cleanup
                    overlay.lightningInterval = lightningInterval;
                    
                    // Stop after win level duration
                    let stopTime = 2000;
                    if (winLevel === 'medium') stopTime = 3000;
                    else if (winLevel === 'big') stopTime = 4000;
                    else if (winLevel === 'mega') stopTime = 5000;
                    
                    setTimeout(() => {
                        if (overlay.lightningInterval) {
                            clearInterval(overlay.lightningInterval);
                        }
                        overlay.classList.add('fading');
                        setTimeout(() => {
                            if (overlay.parentNode) {
                                overlay.remove();
                            }
                        }, 300);
                        window.slotLightningOverlay = null;
                    }, stopTime);
                } else {
                    // For small wins, just show initial bolts and remove
                    setTimeout(() => {
                        overlay.classList.add('fading');
                        setTimeout(() => {
                            if (overlay.parentNode) {
                                overlay.remove();
                            }
                        }, 300);
                        window.slotLightningOverlay = null;
                    }, 800);
                }
                
            } catch (e) {
                console.log('Slot area lightning failed:', e);
            }
        }

        function createReel(columnData, colIndex) {
            const reel = document.createElement('div');
            reel.className = 'reel';

            const column = document.createElement('div');
            column.className = 'symbols-column';

            // Create symbols in correct order for smooth spinning
            // Buffer symbols + target symbols + more buffer = seamless loop
            const totalSymbols = TOTAL_SPIN_SYMBOLS; // use global setting to control spin distance
            
            for (let i = 0; i < totalSymbols; i++) {
                const symbol = document.createElement('div');
                symbol.className = 'symbol-item';
                // Ensure each symbol occupies 1 / totalSymbols of column height
                // height is controlled via CSS variable --symbol-height (set in JS)
                symbol.style.height = 'var(--symbol-height)';
                
                let symbolId;
                if (columnData && columnData.length > 0 && i >= totalSymbols - 6) {
                    // Last 6 symbols are the target result
                    symbolId = columnData[i - (totalSymbols - 6)];
                } else {
                    // All others are random buffer
                    symbolId = symbols[Math.floor(Math.random() * symbols.length)].id;
                }
                
                // compact creation; avoid verbose logging in production
                
                const img = document.createElement('img');
                img.src = getSymbolSrc(symbolId);
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                img.style.display = 'block';
                
                // Add fallback background color for debugging
                symbol.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                symbol.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                
                img.onerror = function() {
                    // Image failed to load  silently fall back
                    this.style.display = 'none';
                    const fallback = document.createElement('div');
                    fallback.textContent = symbolId.toUpperCase();
                    fallback.style.color = '#fff';
                    fallback.style.fontSize = '10px';
                    fallback.style.textAlign = 'center';
                    fallback.style.lineHeight = '1';
                    fallback.style.padding = '2px';
                    symbol.appendChild(fallback);
                };
                
                img.onload = function() {};
                
                symbol.appendChild(img);
                
                symbol.dataset.symbolId = symbolId;
                symbol.dataset.row = i;
                column.appendChild(symbol);
            }

            // Position to show the last 6 symbols (target) as the visible area
            const visibleCount = 6;
            // Set column height proportional to totalSymbols so 6 items remain visible
            column.style.height = `${(totalSymbols / visibleCount) * 100}%`;
            const visibleTranslate = -((totalSymbols - visibleCount) / totalSymbols) * 100;
            column.style.transform = `translateY(${visibleTranslate}%)`;

            reel.appendChild(column);
            // reel created
            return reel;
        }

        function initSlotArea(grid) {
            // initialize slot area with provided grid
            slotArea.innerHTML = '';
            
            const normGrid = normalizeGrid(grid);
            for (let col = 0; col < 6; col++) {
                const reel = createReel(normGrid ? normGrid[col] : [], col);
                slotArea.appendChild(reel);
            }
            // slot area initialized

            // Ensure symbol pixel sizing matches the reel viewport so symbols remain fixed-sized
            try { setSymbolPixelSize(); } catch (e) { console.log('setSymbolPixelSize init failed', e); }

            // Mark visible symbols
            const reels = slotArea.querySelectorAll('.reel');
            reels.forEach(reel => {
                const column = reel.querySelector('.symbols-column');
                const symbols = column.children;
                for (let i = 0; i < symbols.length; i++) {
                    if (i >= symbols.length - 6) {
                        symbols[i].classList.add('active');
                        symbols[i].classList.remove('inactive');
                    } else {
                        symbols[i].classList.add('inactive');
                        symbols[i].classList.remove('active');
                    }
                }
            });
        }

        async function spinReels(targetGrid, winPositions) {
            if (isSpinning) return;
            isSpinning = true;
            spinBtn.disabled = true;

            // starting spin (logs removed for production)
            playSound('spin-sound');
            // Determine pre-configured win level (used later to trigger mega cinematic)
            const preWinLevel = calculateWinLevel(winPositions || []);

            // Spin start effects: flash, motion-blur, top darken, reel pull-down
            try { spinStartEffects(); } catch (e) { console.log('spinStartEffects failed', e); }

            // Zeus reaction during spin: visual nudge but do not relocate off-anchor
            if (zeusController) {
                if (typeof zeusController.onSpin === 'function') zeusController.onSpin(true);
                else if (typeof zeusController.performSequentialMovement === 'function') zeusController.performSequentialMovement();
            }

            const reels = slotArea.querySelectorAll('.reel');
            const promises = [];

            reels.forEach((reel, colIndex) => {
                promises.push(new Promise(resolve => {
                    const column = reel.querySelector('.symbols-column');
                    
                    // Clear current column and rebuild with target at the end
                    column.innerHTML = '';

                    // Create spinning sequence using global TOTAL_SPIN_SYMBOLS so visible grid remains 6 rows.
                    const visibleCount = 6;
                    const spinLength = TOTAL_SPIN_SYMBOLS; // Total symbols in spin sequence
                    
                    // Batch append to avoid layout thrash and set async image decoding/loading
                    const frag = document.createDocumentFragment();
                    for (let i = 0; i < spinLength; i++) {
                        const symbol = document.createElement('div');
                        symbol.className = 'symbol-item';
                        // Ensure each symbol occupies 1 / spinLength of column height during spin
                        // height is controlled via CSS variable --symbol-height (set in JS)
                        symbol.style.height = 'var(--symbol-height)';

                        let symbolId;
                        if (i >= spinLength - 6) {
                            // Last 6 symbols - the target result
                            // Simple: just use the grid directly, no offset manipulation
                            const gridRowIndex = i - (spinLength - 6); // 0-5
                            symbolId = targetGrid[colIndex][gridRowIndex];
                        } else {
                            // Random symbols for spinning effect
                            symbolId = symbols[Math.floor(Math.random() * symbols.length)].id;
                        }

                        // Add lightweight debug styles (won't affect layout)
                        symbol.style.backgroundColor = 'rgba(0, 255, 0, 0.03)';
                        symbol.style.border = '1px solid rgba(255, 255, 255, 0.06)';

                        const img = document.createElement('img');
                        img.loading = 'lazy';
                        img.decoding = 'async';
                        img.draggable = false;
                        img.src = getSymbolSrc(symbolId);
                        img.style.width = '100%';
                        img.style.height = '100%';
                        img.style.objectFit = 'contain';
                        img.style.display = 'block';

                        img.onerror = function() {
                            console.log(`Spin - Failed to load: ${symbolId}`);
                            this.style.display = 'none';
                            const fallback = document.createElement('div');
                            fallback.textContent = symbolId.toUpperCase();
                            fallback.style.color = '#fff';
                            fallback.style.fontSize = '10px';
                            fallback.style.textAlign = 'center';
                            symbol.appendChild(fallback);
                        };
                        symbol.appendChild(img);

                        symbol.dataset.symbolId = symbolId;
                        symbol.dataset.row = i;
                        frag.appendChild(symbol);
                    }
                    column.appendChild(frag);

                    // Set column height dynamically based on spinLength so visible area shows 6 rows
                    column.style.height = `${(spinLength / visibleCount) * 100}%`;
                    
                    // Start from top
                    column.style.transition = 'none';
                    column.style.transform = 'translateY(0%)';
                    
                    // Force reflow
                    column.offsetHeight;

                    // Animate spin - scroll to show the last 6 symbols (target)
                    // All reels START at same time, but have DIFFERENT durations (cascade effect)
                    // First reel is fastest, each subsequent reel is slower
                    // Make base spin feel faster but elongate cascade by increasing per-reel increment
                    // Result: each reel's internal motion is quicker (lower baseDuration)
                    // but the stop cascade takes slightly longer (higher cascadeIncrement)
                    // Make inner spin faster by reducing base duration, while increasing cascade increment
                    let baseDuration = 2000; // faster internal motion
                    if (preWinLevel === 'mega') {
                        baseDuration = 3200;
                    }

                    // Each reel adds this much time to its stop moment (ms)
                    const cascadeIncrement = 300; // stronger cascade: each subsequent reel stops 300ms later
                    let duration = baseDuration + (colIndex * cascadeIncrement);
                    
                    // Add randomness only to MEGA
                    if (preWinLevel === 'mega') {
                        duration += Math.floor(Math.random() * 300);
                    }
                    
                    column.style.transition = 'none'; // Reset transition
                    column.style.transform = `translateY(0%)`; // Reset position
                    
                    // Force reflow to apply position reset
                    column.offsetHeight;
                    
                    // Start animation IMMEDIATELY (no stagger delay) - all reels start together
                    column.style.transition = `transform ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
                    // Compute translate so last `visibleCount` symbols are visible
                    const visibleTranslate = -((spinLength - visibleCount) / spinLength) * 100;
                    column.style.transform = `translateY(${visibleTranslate}%)`;

                    // Resolve after the longest animation (last reel) completes
                    const maxDuration = baseDuration + ((reels.length - 1) * cascadeIncrement) + (preWinLevel === 'mega' ? 300 : 0);
                    if (colIndex === reels.length - 1) {
                        setTimeout(() => { resolve(); }, maxDuration + 60);
                    } else {
                        // Other reels resolve when their individual animation completes
                        setTimeout(() => { resolve(); }, duration + 60);
                    }
                }));
            });

            await Promise.all(promises);

            // Mark visible symbols
            const visibleReels = slotArea.querySelectorAll('.reel');
            visibleReels.forEach(reel => {
                const column = reel.querySelector('.symbols-column');
                const symbols = column.children;
                for (let i = 0; i < symbols.length; i++) {
                    if (i >= symbols.length - 6) {
                        symbols[i].classList.add('active');
                        symbols[i].classList.remove('inactive');
                    } else {
                        symbols[i].classList.add('inactive');
                        symbols[i].classList.remove('active');
                    }
                }
            });

            // Remove motion blur now that reels stopped
            try { removeMotionBlurOnReels(); } catch (e) { console.log('removeMotionBlurOnReels failed', e); }

            // If this spin was a pre-configured mega, now that reels stopped, center Zeus and play mega cinematic
            if (preWinLevel === 'mega') {
                try {
                    // Swap Zeus artwork to the super-charging pose (ensure visible when centering)
                    zeusImg.src = 'assets/animations/zeus_pose_all-zeus_super_charging_wild.gif';

                    // Center Zeus now (after spin completes)
                    if (zeusController && typeof zeusController.setToAnchor === 'function') {
                        zeusController.setToAnchor('center', true);
                    } else if (zeusController && typeof zeusController.moveToSide === 'function') {
                        zeusController.moveToSide('center');
                    }

                    // Trigger existing Zeus lightning and fullscreen cinematic flash
                    createZeusLightning();
                    createFullScreenLightning();
                    playSound('mega-win-sound');
                } catch (e) { console.log('Error triggering delayed mega Zeus cinematic', e); }
            }

            // Calculate win level for showing status
            const winLevel = calculateWinLevel(winPositions || []);
            
            // Show winning animations (this will handle the complete sequence now)
            if (winPositions && winPositions.length > 0) {
                await showWinningAnimations(winPositions);
            } else {
                // For no wins, deduct a small percent from total and show loss status
                try {
                    const deducted = applyLossPercentage();
                    if (deducted > 0) {
                        // Optionally update previous win block to reflect loss
                        updatePreviousWin(0);
                    }
                } catch(e) { console.log('loss deduction failed', e); }
                setTimeout(() => showWinStatus(winLevel), 500);
            }

            isSpinning = false;
            spinBtn.disabled = false;
            try {
                // Reveal the title again now that the spin/result flow completed
                if (title) { title.style.transition = 'opacity 220ms ease'; title.style.opacity = '1'; }
            } catch (e) {}
        }

        // Win level calculation
        function calculateWinLevel(winPositions) {
            const winCount = winPositions.length;
            if (winCount === 0) return 'none';
            if (winCount <= 3) return 'small';
            if (winCount <= 6) return 'medium';
            if (winCount <= 9) return 'big';
            return 'mega';
        }

        function getRandomWinAmount(level) {
            switch(level) {
                case 'small': return Math.floor(Math.random() * 50) + 10; // 10-60
                case 'medium': return Math.floor(Math.random() * 150) + 75; // 75-225
                case 'big': return Math.floor(Math.random() * 400) + 250; // 250-650
                case 'mega': return Math.floor(Math.random() * 1500) + 1000; // 1000-2500
                default: return 0;
            }
        }

        // (removed) previous animated win-counter implementation. Keep compatibility stub.
        async function animateWinCounter(amount) { return Promise.resolve(); }

        // showBigWinBoard removed (big-win-board UI removed)

        // Simple total update: add amount and update DOM without extra flying effects.
        function updateTotalWin(addAmount) {
            totalWinAmount += addAmount;
            totalWinAmountEl.textContent = totalWinAmount;
            // brief sound feedback
            try { playSound('coin-sound'); } catch (e) {}
        }

        // Single add-to-total effect: show one overlay above slot area and credit immediately.
        // Smoothly increment the total win display over `duration` ms
        function animateCreditToTotal(amount, duration = 900) {
            return new Promise(resolve => {
                const start = totalWinAmount;
                const end = totalWinAmount + amount;
                const startTime = performance.now();

                function step(now) {
                    const t = Math.min(1, (now - startTime) / duration);
                    const value = Math.floor(start + (end - start) * t);
                    try { totalWinAmountEl.textContent = value; } catch (e) {}
                    if (t < 1) requestAnimationFrame(step);
                    else {
                        totalWinAmount = end;
                        try { totalWinAmountEl.textContent = totalWinAmount; } catch(e){}
                        resolve();
                    }
                }

                requestAnimationFrame(step);
            });
        }

        // Simple add-to-total without flying coins animation (removed)
        async function showSingleAddToTotal(amount) {
            // Just update the total directly - no coin animation
            try {
                await animateCreditToTotal(amount, 900);
                try { playSound('coin-sound'); } catch(e) {}
            } catch(e) { 
                updateTotalWin(amount);
            }
        }

        // Reset total win amount
        function resetTotalWin() {
            totalWinAmount = 0;
            totalWinAmountEl.textContent = '0';
        }

        // Update previous win block
        function updatePreviousWin(amount) {
            if (!previousWinBlock || !previousWinAmountEl) return; // block removed
            if (amount > 0) {
                previousWinBlock.classList.add('highlight');
                previousWinAmountEl.textContent = amount;

                // Remove highlight after showing
                setTimeout(() => {
                    if (previousWinBlock) previousWinBlock.classList.remove('highlight');
                }, 2000);
            }
        }

        // Show win status
        function showWinStatus(winLevel) {
            const statusMessages = {
                'none': 'No Win',
                'small': 'Small Win!',
                'medium': 'Big Win!',
                'big': 'Very Big Win!',
                'mega': 'MEGA WIN!!!'
            };

            winStatus.textContent = statusMessages[winLevel] || 'No Win';
            winStatus.className = `win-status ${winLevel}`;
            winStatus.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                winStatus.classList.remove('show');
            }, 3000);
        }

        async function showWinningAnimations(winPositions) {
            return new Promise(async resolve => {
                // starting cinematic win animation (logs removed)
                
                // Calculate win level
                const winLevel = calculateWinLevel(winPositions);
                // win level computed
                
                // If no win, just show status and return
                if (winLevel === 'none' || winPositions.length === 0) {
                    setTimeout(() => showWinStatus(winLevel), 500);
                    resolve();
                    return;
                }

                // Start cinematic win sequence
                cinematicController.startCinematicWin(winPositions, winLevel);

                // When cinematic finishes, perform Zeus strikes on winning symbols, then cascade
                const checkCompletion = async () => {
                    if (cinematicController.currentPhase === 'waiting') {
                        try {
                            // For big (and mega) wins: swap Zeus artwork to super-charging GIF
                            // and start continuous Zeus lightning + subtle hover.
                            if (winLevel === 'big' || winLevel === 'mega') {
                                try { zeusImg.src = 'assets/animations/zeus_pose_all-zeus_super_charging_wild.gif'; } catch(e) {}
                                try { if (zeusController && typeof zeusController.startHover === 'function') zeusController.startHover(6, 0.75); } catch(e) {}
                                try { createZeusLightning(); } catch(e) {}
                            }

                            // After cinematic phase reaches waiting: explode and fill initial winning symbols
                            await simultaneousExplodeAndFill(winPositions, winLevel);

                            // If the cinematic started an extended win flow (mega), wait for it to finish
                            if (cinematicController.winFlowPromise) {
                                try { await cinematicController.winFlowPromise; } catch(e) { console.log('winFlowPromise error', e); }
                            }
                        } catch (e) { console.log('simultaneousExplodeAndFill error', e); }

                        resolve();
                    } else {
                        setTimeout(checkCompletion, 100);
                    }
                };

                setTimeout(checkCompletion, 3000); // Minimum wait time
            });
        }

        async function performSymbolCascade(winPositions, winLevel) {
            const reels = slotArea.querySelectorAll('.reel');
            // For backward compatibility keep this function but delegate to simultaneous flow
            return simultaneousExplodeAndFill(winPositions, winLevel);
        }

        async function performCascade(winPositions) {
            return new Promise(resolve => {
                const reels = slotArea.querySelectorAll('.reel');
                
                // Group winning positions by column
                const winsByColumn = {};
                winPositions.forEach(([col, row]) => {
                    if (!winsByColumn[col]) winsByColumn[col] = [];
                    winsByColumn[col].push(row);
                });

                Object.keys(winsByColumn).forEach(colIndex => {
                    const col = parseInt(colIndex);
                    const reel = reels[col];
                    const column = reel.querySelector('.symbols-column');
                    const winningRows = winsByColumn[col].sort((a, b) => b - a); // Sort descending
                    
                    // Remove winning symbols from DOM
                    const totalSymbols = column.children.length;
                    const symbolsToRemove = [];
                    
                    // Compute symbol indices relative to the current DOM ordering.
                    // Visible symbols are the last `visibleCount` children (we render so last items are visible),
                    // so map visible row (0..visibleCount-1) to child index: len - visibleCount + row
                    const visibleCount = 6;
                    const currentLen = column.children.length;
                    winningRows.forEach(row => {
                        const symbolIndex = currentLen - visibleCount + row;
                        const symbolElement = column.children[symbolIndex];
                        if (symbolElement) symbolsToRemove.push(symbolElement);
                    });

                    // Remove the symbols
                    symbolsToRemove.forEach(symbol => {
                        symbol.remove();
                    });

                    // Create new symbols to fill the gaps
                    const newSymbols = [];
                    const spinLength = TOTAL_SPIN_SYMBOLS;
                    for (let i = 0; i < symbolsToRemove.length; i++) {
                        const symbol = document.createElement('div');
                        symbol.className = 'symbol-item falling';
                        // height is controlled via CSS variable --symbol-height (set in JS)
                        symbol.style.height = 'var(--symbol-height)';
                        symbol.style.backgroundColor = 'rgba(0, 255, 0, 0.03)';
                        symbol.style.border = '1px solid rgba(255, 255, 255, 0.06)';

                        const randomSymbolId = symbols[Math.floor(Math.random() * symbols.length)].id;

                        const img = document.createElement('img');
                        img.loading = 'lazy';
                        img.decoding = 'async';
                        img.draggable = false;
                        img.src = getSymbolSrc(randomSymbolId);
                        img.style.width = '100%';
                        img.style.height = '100%';
                        img.style.objectFit = 'contain';
                        img.style.display = 'block';

                        img.onerror = function() {
                            this.style.display = 'none';
                            const fallback = document.createElement('div');
                            fallback.textContent = randomSymbolId.toUpperCase();
                            fallback.style.color = '#fff';
                            fallback.style.fontSize = '10px';
                            fallback.style.textAlign = 'center';
                            symbol.appendChild(fallback);
                        };
                        symbol.appendChild(img);

                        symbol.dataset.symbolId = randomSymbolId;
                        newSymbols.push(symbol);
                    }

                    // Insert new symbols at the top so the visible area (last 6 items) stays aligned.
                    const currentAfterRemovalLen = column.children.length;
                    const visibleStartIndex = Math.max(0, currentAfterRemovalLen - 6);
                    // Insert in order so the first new symbol ends up nearest the visible area
                    for (let i = newSymbols.length - 1; i >= 0; i--) {
                        const symbol = newSymbols[i];
                        if (column.children[visibleStartIndex]) column.insertBefore(symbol, column.children[visibleStartIndex]);
                        else column.appendChild(symbol);
                    }

                    // Normalize sizing in pixels to avoid sub-pixel rounding causing uneven gaps.
                    try {
                        const reelEl = reel.getBoundingClientRect ? reel : reel;
                        // reel viewport height
                        const reelHeight = reel.getBoundingClientRect().height;
                        const columnHeightPx = (spinLength / visibleCount) * reelHeight;
                        // Force column to exact pixel height to avoid percent rounding
                        column.style.height = `${columnHeightPx}px`;
                        const symbolPx = columnHeightPx / spinLength;
                        Array.from(column.children).forEach(ch => {
                            ch.style.height = `${symbolPx}px`;
                        });
                    } catch (e) {
                        // If anything fails, fall back to percent heights (already set elsewhere)
                        console.log('normalize column sizing failed', e);
                    }
                });

                // Wait for cascade animation
                setTimeout(() => {
                    // Remove falling class
                    const fallingSymbols = slotArea.querySelectorAll('.symbol-item.falling');
                    fallingSymbols.forEach(symbol => {
                        symbol.classList.remove('falling');
                    });

                    // Re-mark visible symbols after cascade
                    const reels = slotArea.querySelectorAll('.reel');
                    reels.forEach(reel => {
                        const column = reel.querySelector('.symbols-column');
                        const symbols = column.children;
                        for (let i = 0; i < symbols.length; i++) {
                            if (i >= symbols.length - 6) {
                                symbols[i].classList.add('active');
                                symbols[i].classList.remove('inactive');
                            } else {
                                symbols[i].classList.add('inactive');
                                symbols[i].classList.remove('active');
                            }
                        }
                    });

                    resolve();
                }, 500);
            });
        }

        const winLevelUI = {
            'none': {
                zeus: "assets/animations/zeus_pose_all-zeus_idle.gif",
                title: "Try Again",
                btnText: "SPIN",
            },
            'small': {
                zeus: "assets/animations/zeus_pose_all-zeus_idle_thunder.gif",
                title: "Small Win!",
                btnText: "SPIN",
            },
            'medium': {
                zeus: "assets/animations/zeus_pose_all-zeus_summon_titan_symbol.gif",
                title: "Medium Win!",
                btnText: "SPIN",
            },
            'big': {
                zeus: "assets/animations/zeus_pose_all-zeus_idle_thunder.gif",
                title: "Big Win!",
                btnText: "SPIN",
            },
            'mega': {
                zeus: "assets/animations/zeus_pose_all-zeus_super_charging_wild.gif",
                title: "MEGA WIN",
                btnText: "COLLECT BONUS",
            }
        };

        function updateUIForWinLevel(winLevel) {
            const uiData = winLevelUI[winLevel] || winLevelUI['none'];
            
            zeusImg.src = uiData.zeus;
            title.textContent = uiData.title;
            spinBtn.textContent = uiData.btnText;

            if (winLevel === 'mega') {
                spinBtn.classList.add('collect-btn');
                spinBtn.classList.remove('bonus-btn');
            } else {
                spinBtn.classList.remove('bonus-btn', 'collect-btn');
            }
        }

        async function nextSpin() {
            if (isSpinning) return;

            if (spinBtn.classList.contains('collect-btn')) {
                try { removeFullScreenLightning(); } catch(e) {}
                try { if (zeusController && typeof zeusController.stopHover === 'function') zeusController.stopHover(); } catch(e) {}
                try { stopZeusLightning(); } catch(e) {}
                resetTotalWin();
                updatePreviousWin(0);
                
                updateUIForWinLevel('none');
                title.textContent = "Battle for the Power of Olympus";

                initSlotArea(generateRandomGrid());
                spinCount = 0; // Reset spin count
                return;
            }

            const outcome = predefinedOutcomes[spinCount % predefinedOutcomes.length];
            spinCount++;

            let randomGrid;
            let winPositions = [];
            let winLevel = 'none';

            switch (outcome) {
                case 'win':
                    winLevel = 'small';
                    break;
                case 'bigger_win':
                    winLevel = 'big';
                    break;
                case 'fake_lose':
                    winLevel = 'none';
                    break;
                case 'mega_win':
                    winLevel = 'mega';
                    break;
            }

            if (winLevel !== 'none') {
                const possibleCombinations = combinations.filter(c => c.winLevel === winLevel);
                const randomCombination = possibleCombinations[Math.floor(Math.random() * possibleCombinations.length)];
                if (randomCombination) {
                    randomGrid = generateGridFromCombination(randomCombination);
                    const evaluation = evaluateGrid(randomGrid);
                    winPositions = evaluation.winPositions;
                } else {
                    // Fallback to random grid if no combination found for the winLevel
                    randomGrid = generateRandomGrid();
                    winPositions = [];
                    winLevel = 'none';
                }
            } else {
                randomGrid = generateRandomGrid();
                winPositions = [];
                winLevel = 'none';
            }
            
            await spinReels(randomGrid, winPositions);

            updateUIForWinLevel(winLevel);
        }

        // Event listeners
        spinBtn.addEventListener('click', () => {
            playSound('click-sound');
            // Stop any ongoing cinematic effects before starting new spin
            if (cinematicController && cinematicController.isActive) {
                cinematicController.stopCinematicWin();
                // Reset camera zoom
                gameContainer.style.transform = '';
                gameContainer.style.transformOrigin = '';
            }
            try {
                // Hide the main title text immediately on click for cleaner spin UX
                if (title) { title.style.transition = 'opacity 160ms ease'; title.style.opacity = '0'; }
            } catch(e) {}

            // Ensure Zeus animates to the center anchor when the player clicks to spin
            try {
                if (zeusController && typeof zeusController.setToAnchor === 'function') {
                    // animate Zeus to center (do not force instant to keep motion)
                    zeusController.setToAnchor('center', false);
                }
            } catch (e) { /* ignore */ }

            // If this button is currently acting as a COLLECT link, use the configured data-href.
            try {
                if (spinBtn.classList && spinBtn.classList.contains('collect-btn')) {
                    const href = spinBtn.getAttribute('data-href') || '#';
                    if (href === '#') {
                        try { window.location.hash = href; } catch(e) { /* ignore */ }
                    } else {
                        try { window.location.href = href; } catch(e) { try { window.location.hash = '#'; } catch(_){} }
                    }
                    return;
                }
            } catch(e) { /* ignore */ }

            nextSpin();
        });

        // Cinematic Win Animation Controller
        class CinematicWinController {
            constructor() {
                this.canvas = document.getElementById('cinematic-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameContainer = document.querySelector('.game-container');
                this.slotArea = document.querySelector('.slot-area');
                this.zeusContainer = document.querySelector('.zeus-container');
                this.isActive = false;
                this.currentPhase = null;
                this.startTime = 0;
                this.winLevel = null;
                this.winPositions = [];
                this.winAmount = 0;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.gameContainer.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.gameRect = rect;
            }

            startCinematicWin(winPositions, winLevel) {
                this.winPositions = winPositions;
                this.winLevel = winLevel;
                this.winAmount = getRandomWinAmount(winLevel);
                this.isActive = true;
                this.startTime = performance.now();
                this.currentPhase = 'divine_flash';
                
                this.canvas.classList.add('active');
                
                // Play initial sound
                if (winLevel === 'mega') {
                    playSound('mega-win-sound');
                } else if (winLevel === 'big') {
                    playSound('big-win-sound');
                } else {
                    playSound('win-sound');
                }
                
                this.animate();
            }

            stopCinematicWin() {
                this.isActive = false;
                this.currentPhase = null;
                this.canvas.classList.remove('active');
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Stop Zeus lightning unless this was a MEGA flow (MEGA keeps lightning until collect)
                try {
                    if (this.winLevel !== 'mega') stopZeusLightning();
                } catch(e) {}
                
                // Reset Zeus position
                if (zeusController) {
                    zeusController.moveToSide('right');
                }
            }

            animate() {
                if (!this.isActive) return;
                
                const currentTime = performance.now();
                const elapsed = currentTime - this.startTime;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Phase management
                // Shortened cinematic timings for snappier feel
                if (this.currentPhase === 'divine_flash' && elapsed >= 200) {
                    this.currentPhase = 'lightning_expansion';
                } else if (this.currentPhase === 'lightning_expansion' && elapsed >= 700) {
                    this.currentPhase = 'zeus_movement';
                } else if (this.currentPhase === 'zeus_movement' && elapsed >= 1100) {
                    this.currentPhase = 'zeus_lightning';
                } else if (this.currentPhase === 'zeus_lightning' && elapsed >= 1400) {
                    this.currentPhase = 'win_counter';
                }
                
                // Render current phase
                switch (this.currentPhase) {
                    case 'divine_flash':
                        this.renderDivineFlash(elapsed);
                        break;
                    case 'lightning_expansion':
                        this.renderLightningExpansion(elapsed);
                        break;
                    case 'zeus_movement':
                        this.renderZeusMovement(elapsed);
                        break;
                    case 'zeus_lightning':
                        this.renderZeusLightning(elapsed);
                        break;
                    case 'win_counter':
                        this.renderWinCounter(elapsed);
                        break;
                }
                
                requestAnimationFrame(() => this.animate());
            }

            renderDivineFlash(elapsed) {
                const progress = elapsed / 300; // 0 to 1 over 300ms
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Create expanding flash effect
                const radius = progress * 200;
                const gradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * (1 - progress)})`);
                gradient.addColorStop(0.5, `rgba(255, 215, 0, ${0.6 * (1 - progress)})`);
                gradient.addColorStop(1, `rgba(255, 215, 0, ${0.2 * (1 - progress)})`);
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add electric discharge sound effect
                if (elapsed < 50) {
                    // Play quiet electric sound
                }
            }

            renderLightningExpansion(elapsed) {
                const progress = (elapsed - 300) / 900; // 0 to 1 over 900ms
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Create expanding lightning beam
                const beamLength = progress * Math.max(this.canvas.width, this.canvas.height);
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = '#ffffff';
                this.ctx.shadowBlur = 10;
                
                // Draw jagged lightning beam in all directions
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    
                    const segments = 8;
                    let currentX = centerX;
                    let currentY = centerY;
                    
                    for (let i = 1; i <= segments; i++) {
                        const segmentProgress = i / segments * progress;
                        const targetX = centerX + Math.cos(angle) * beamLength * segmentProgress;
                        const targetY = centerY + Math.sin(angle) * beamLength * segmentProgress;
                        
                        // Add jaggedness
                        const jitter = (Math.random() - 0.5) * 20 * (1 - segmentProgress);
                        currentX = centerX + Math.cos(angle) * beamLength * segmentProgress + jitter;
                        currentY = centerY + Math.sin(angle) * beamLength * segmentProgress + jitter;
                        
                        this.ctx.lineTo(currentX, currentY);
                    }
                    
                    this.ctx.stroke();
                }
                
                // Highlight winning symbols with golden outline
                if (progress > 0.3) {
                    this.highlightWinningSymbols();
                }
                
                // Add flash effects to symbols - removed to prevent flashing
                // if (progress > 0.5) {
                //     this.renderSymbolFlashes(progress);
                // }
            }

            highlightWinningSymbols() {
                const reels = this.slotArea.querySelectorAll('.reel');
                this.winPositions.forEach(([col, row]) => {
                    const reel = reels[col];
                    if (reel) {
                        const column = reel.querySelector('.symbols-column');
                        const totalSymbols = column.children.length;
                        const symbolIndex = totalSymbols - 6 + row;
                        const symbolElement = column.children[symbolIndex];
                        if (symbolElement) {
                            symbolElement.classList.add('winning', 'golden-highlight');
                        }
                    }
                });
            }

            renderSymbolFlashes(progress) {
                const reels = this.slotArea.querySelectorAll('.reel');
                this.winPositions.forEach(([col, row]) => {
                    const reel = reels[col];
                    if (reel) {
                        const column = reel.querySelector('.symbols-column');
                        const totalSymbols = column.children.length;
                        const symbolIndex = totalSymbols - 6 + row;
                        const symbolElement = column.children[symbolIndex];
                        if (symbolElement) {
                            const rect = symbolElement.getBoundingClientRect();
                            const canvasRect = this.canvas.getBoundingClientRect();
                            
                            const x = rect.left - canvasRect.left;
                            const y = rect.top - canvasRect.top;
                            const width = rect.width;
                            const height = rect.height;
                            
                            // Flash effect
                            const flashIntensity = Math.sin(progress * 20) * 0.5 + 0.5;
                            this.ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.8})`;
                            this.ctx.fillRect(x, y, width, height);
                            
                            // Golden border
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeRect(x, y, width, height);
                        }
                    }
                });
            }

            renderZeusMovement(elapsed) {
                const progress = (elapsed - 1200) / 800; // 0 to 1 over 800ms
                
                // Move Zeus to center position
                if (progress < 0.1 && zeusController) {
                    zeusController.moveToSide('center');
                }
                
                // Add light discharges around Zeus
                if (progress > 0.2) {
                    this.renderZeusLightDischarges(progress);
                }
                
                // Add camera zoom effect
                if (progress > 0.5) {
                    this.applyCameraZoom(progress);
                }
                
                // Add Zeus glow effect
                this.renderZeusGlow(progress);
            }

            renderZeusLightDischarges(progress) {
                if (!this.zeusContainer) return;
                
                const rect = this.zeusContainer.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                const zeusCenterX = rect.left - canvasRect.left + rect.width / 2;
                const zeusCenterY = rect.top - canvasRect.top + rect.height / 2;
                
                // Draw light discharges around hands and eyes
                const dischargeCount = Math.floor(progress * 6) + 2;
                
                for (let i = 0; i < dischargeCount; i++) {
                    const angle = (Math.PI * 2 * i) / dischargeCount + progress * 2;
                    const distance = 30 + Math.sin(progress * 10 + i) * 10;
                    const endX = zeusCenterX + Math.cos(angle) * distance;
                    const endY = zeusCenterY + Math.sin(angle) * distance;
                    
                    this.ctx.strokeStyle = '#87CEEB';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = '#87CEEB';
                    this.ctx.shadowBlur = 5;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(zeusCenterX, zeusCenterY);
                    
                    // Jagged discharge
                    const segments = 4;
                    let currentX = zeusCenterX;
                    let currentY = zeusCenterY;
                    
                    for (let j = 1; j <= segments; j++) {
                        const segmentX = zeusCenterX + Math.cos(angle) * distance * (j / segments);
                        const segmentY = zeusCenterY + Math.sin(angle) * distance * (j / segments);
                        const jitter = (Math.random() - 0.5) * 8;
                        
                        currentX = segmentX + jitter;
                        currentY = segmentY + jitter;
                        this.ctx.lineTo(currentX, currentY);
                    }
                    
                    this.ctx.stroke();
                }
            }

            applyCameraZoom(progress) {
                const zoomProgress = Math.min(progress * 2, 1); // Faster zoom
                const scale = 1 + zoomProgress * 0.1; // 1.0 to 1.1
                
                // Camera zoom effect removed
                // this.gameContainer.style.transform = `scale(${scale})`;
                // this.gameContainer.style.transformOrigin = 'center center';
            }

            renderZeusGlow(progress) {
                if (!this.zeusContainer) return;
                
                const rect = this.zeusContainer.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                const zeusCenterX = rect.left - canvasRect.left + rect.width / 2;
                const zeusCenterY = rect.top - canvasRect.top + rect.height / 2;
                
                // Create glowing aura around Zeus
                const glowRadius = 80 + progress * 40;
                const gradient = this.ctx.createRadialGradient(
                    zeusCenterX, zeusCenterY, 0,
                    zeusCenterX, zeusCenterY, glowRadius
                );
                
                const glowIntensity = 0.3 + progress * 0.4;
                gradient.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity})`);
                gradient.addColorStop(0.5, `rgba(255, 165, 0, ${glowIntensity * 0.6})`);
                gradient.addColorStop(1, `rgba(255, 140, 0, ${glowIntensity * 0.2})`);
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(zeusCenterX, zeusCenterY, glowRadius, 0, Math.PI * 2);
                this.ctx.fill();
            }

            renderZeusLightning(elapsed) {
                // Start continuous Zeus lightning if not already active
                if (!window.zeusLightningOverlay) {
                    createZeusLightning();
                }
                
                // Add screen shake effect occasionally
                if (Math.random() < 0.1) {
                    this.applyScreenShake();
                }
                
                // Add additional lightning particles around Zeus
                this.renderLightningParticles(elapsed);
            }

            applyScreenShake() {
                this.gameContainer.style.transform += ' translateX(2px)';
                setTimeout(() => {
                    this.gameContainer.style.transform = this.gameContainer.style.transform.replace(' translateX(2px)', '');
                }, 50);
            }

            renderLightningParticles(elapsed) {
                if (!this.zeusContainer) return;
                
                const rect = this.zeusContainer.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                const zeusCenterX = rect.left - canvasRect.left + rect.width / 2;
                const zeusCenterY = rect.top - canvasRect.top + rect.height / 2;
                
                // Create floating lightning particles
                const particleCount = 8;
                const progress = (elapsed - 2000) / 500; // Progress within this phase
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount + progress * 0.5;
                    const distance = 60 + Math.sin(progress * 5 + i) * 20;
                    const particleX = zeusCenterX + Math.cos(angle) * distance;
                    const particleY = zeusCenterY + Math.sin(angle) * distance;
                    
                    // Draw small lightning particle
                    this.ctx.fillStyle = '#87CEEB';
                    this.ctx.shadowColor = '#87CEEB';
                    this.ctx.shadowBlur = 8;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Reset shadow
                    this.ctx.shadowBlur = 0;
                }
            }

            renderWinCounter(elapsed) {
                const progress = Math.min(Math.max((elapsed - 1400) / 1200, 0), 1); // faster: 0 to 1 over ~1.2s
                
                if (progress >= 1) {
                    this.showWinAmount();
                    this.currentPhase = 'waiting';
                } else {
                    // Render animated win amount counter
                    this.renderAnimatedWinCounter(progress);
                }
            }

            renderAnimatedWinCounter(progress) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Calculate current amount to display
                const currentAmount = Math.floor(this.winAmount * progress);
                
                // Draw win amount text
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Text shadow/glow effect
                this.ctx.shadowColor = '#FFD700';
                this.ctx.shadowBlur = 10;
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillText(`+${currentAmount}`, centerX, centerY);
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
                
                // Add particle effects around the text
                if (progress > 0.1) {
                    this.renderWinCounterParticles(progress, centerX, centerY);
                }
            }

            renderWinCounterParticles(progress, centerX, centerY) {
                const particleCount = Math.floor(progress * 20) + 5;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount + progress * 2;
                    const distance = 80 + Math.sin(progress * 8 + i) * 30;
                    const particleX = centerX + Math.cos(angle) * distance;
                    const particleY = centerY + Math.sin(angle) * distance;
                    
                    // Draw coin/sparkle particle
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.shadowColor = '#FFD700';
                    this.ctx.shadowBlur = 5;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, 2 + Math.sin(progress * 10 + i) * 1, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Reset shadow
                    this.ctx.shadowBlur = 0;
                }
            }

            showWinAmount() {
                // Small overlay removed; use single add-to-total effect below
                // Update previous win display (keeps record of raw win before any multiplier/deduction)
                updatePreviousWin(this.winAmount);

                // If small win, apply configured deduction percent before crediting
                let creditedAmount = this.winAmount;
                if (this.winLevel === 'small') {
                    try {
                        const penalty = Math.round(this.winAmount * (smallWinPenaltyPercent / 100));
                        creditedAmount = Math.max(0, this.winAmount - penalty);
                        // Deduction applied silently (no percent overlay shown)
                    } catch (e) {
                        console.log('Deduction application failed', e);
                    }
                }

                // For mega wins, play an extended cinematic: falling multiplier, additional cascades,
                // heavier confetti, and gradual crediting of points.
                if (this.winLevel === 'mega') {
                    // Launch an asynchronous mega flow and keep a Promise on the controller
                    this.winFlowPromise = (async () => {
                        try {
                                    // Spawn a big MEGA WIN title
                                    showLargeMegaText();

                                    // Strong cinematic start: fullscreen flash + persistent Zeus lightning
                                    try { createFullScreenLightning(); } catch(e) {}
                                    try { createZeusLightning(); } catch(e) {}

                                    // Spawn a falling multiplier (x25..x50) and apply
                                    const multiplier = 25 + Math.floor(Math.random() * 26); // 25..50
                                    await spawnFallingMultiplier(multiplier);
                                    const multiplied = Math.round(creditedAmount * multiplier);
                                    this.winAmount = multiplied;

                                    // Big cinematic shakes and heavy confetti
                                    gameContainer.classList.add('screen-shake');
                                    setTimeout(() => gameContainer.classList.remove('screen-shake'), 1600);
                                    createConfettiAt(this.slotArea, 120);

                                    // Perform multiple additional cascades for drama (2-3 cascades)
                                    const cascadeCount = 2 + Math.floor(Math.random() * 2); // 2..3
                                    for (let i = 0; i < cascadeCount; i++) {
                                        // small delay between cascades to let visuals settle
                                        await performRandomCascade();
                                        // energetic burst after each cascade
                                        try { createConfettiAt(this.slotArea, 48 + i * 12); } catch(e){}
                                        try { gameContainer.classList.add('screen-shake'); setTimeout(() => gameContainer.classList.remove('screen-shake'), 420); } catch(e){}
                                        await new Promise(r => setTimeout(r, 520 + i * 120));
                                    }

                                    // Gradually credit to total over 3s for dramatic effect
                                    await animateCreditToTotal(this.winAmount, 3000);

                                    // Remove MEGA text after short delay
                                    setTimeout(() => removeLargeMegaText(), 1200);
                        } catch (e) {
                            console.log('Mega cinematic error', e);
                            updateTotalWin(creditedAmount);
                        } finally {
                            try {
                                // For mega wins we want Zeus lightning / fullscreen lightning to persist
                                // until the player explicitly collects the bonus. Only cleanup for non-mega flows.
                                if (this.winLevel !== 'mega') {
                                    try { stopZeusLightning(); } catch(e){}
                                    try { removeFullScreenLightning(); } catch(e){}
                                    try { if (typeof cinematicController !== 'undefined' && cinematicController) cinematicController.stopCinematicWin(); } catch(e){}
                                }
                            } catch(e) { console.log('mega cleanup error', e); }
                            this.winFlowPromise = null;
                        }
                    })();
                } else {
                    this.winFlowPromise = null;
                    // Single add-to-total overlay and credit the amount for non-mega
                    updateTotalWin(creditedAmount);
                }
                // Big-win board removed; other cinematic effects handled elsewhere
            }
        }

        /* ----- Helper functions for new slot animations ----- */
        function spinStartEffects() {
            try {
                // Add full-screen subtle flash
                const existing = document.querySelector('.spin-start-flash');
                if (existing) existing.remove();
                const flash = document.createElement('div');
                flash.className = 'spin-start-flash';
                document.querySelector('.game-container').appendChild(flash);

                // Darken top of slot slightly
                const sa = document.querySelector('.slot-area');
                if (sa) sa.classList.add('top-darkened');

                // Apply pull-down to reels (visual)
                const reels = document.querySelectorAll('.reel');
                reels.forEach(r => r.classList.add('pull-down'));

                // Apply motion blur to symbol columns while spinning
                applyMotionBlurOnReels();

                // Remove transient classes after short durations
                setTimeout(() => {
                    // remove pull-down after it visually completes
                    reels.forEach(r => r.classList.remove('pull-down'));
                }, 520);

                setTimeout(() => {
                    if (sa) sa.classList.remove('top-darkened');
                }, 800);

            } catch (e) { console.log('spinStartEffects err', e); }
        }

        function applyMotionBlurOnReels() {
            const columns = document.querySelectorAll('.symbols-column');
            columns.forEach(col => col.classList.add('spinning'));
        }

        function removeMotionBlurOnReels() {
            const columns = document.querySelectorAll('.symbols-column');
            columns.forEach(col => col.classList.remove('spinning'));
        }

        // Note: penalty overlay removed  deductions are applied silently

        // Show large MEGA WIN text overlay
        function showLargeMegaText() {
            try {
                const el = document.createElement('div');
                el.className = 'mega-win-overlay';
                el.style.position = 'absolute';
                el.style.left = '50%';
                el.style.top = '30%';
                el.style.transform = 'translate(-50%, -50%) scale(0.8)';
                el.style.zIndex = 100000;
                el.style.pointerEvents = 'none';
                el.style.color = '#FFD700';
                el.style.textAlign = 'center';
                el.style.fontFamily = 'Impact, Arial Black, sans-serif';
                el.style.fontSize = '84px';
                el.style.letterSpacing = '2px';
                el.style.textShadow = '0 6px 18px rgba(0,0,0,0.6), 0 0 18px rgba(255,215,0,0.6)';
                el.style.opacity = '0';
                el.textContent = 'MEGA WIN';
                document.querySelector('.game-container').appendChild(el);
                requestAnimationFrame(() => {
                    el.style.transition = 'transform 500ms cubic-bezier(0.2,0.9,0.2,1), opacity 420ms ease-out';
                    el.style.transform = 'translate(-50%, -50%) scale(1)';
                    el.style.opacity = '1';
                });
            } catch (e) { console.log('showLargeMegaText error', e); }
        }

        function removeLargeMegaText() {
            try {
                const el = document.querySelector('.mega-win-overlay');
                if (!el) return;
                el.style.transition = 'transform 320ms ease-in, opacity 280ms ease-in';
                el.style.transform = 'translate(-50%, -50%) scale(0.8)';
                el.style.opacity = '0';
                setTimeout(() => { try { el.remove(); } catch(e){} }, 360);
            } catch (e) { console.log('removeLargeMegaText error', e); }
        }

        // Spawn a falling multiplier from the top center; resolves when it lands
        function spawnFallingMultiplier(multiplier) {
            return new Promise(resolve => {
                try {
                    const container = document.querySelector('.game-container');
                    const el = document.createElement('div');
                    el.className = 'falling-multiplier';
                    el.style.position = 'absolute';
                    el.style.left = '50%';
                    el.style.top = '-10%';
                    el.style.transform = 'translateX(-50%) scale(0.8)';
                    el.style.zIndex = 100001;
                    el.style.pointerEvents = 'none';
                    el.style.color = '#fff';
                    el.style.textAlign = 'center';
                    el.style.fontFamily = 'Impact, Arial Black, sans-serif';
                    el.style.fontSize = '44px';
                    el.style.padding = '12px 22px';
                    el.style.background = 'linear-gradient(90deg,#FFCF4D,#FF6B35)';
                    el.style.borderRadius = '10px';
                    el.style.boxShadow = '0 10px 40px rgba(0,0,0,0.5), 0 0 24px rgba(255,215,0,0.6)';
                    el.style.opacity = '0';
                    el.textContent = `x${multiplier}`;
                    container.appendChild(el);

                    // Animate falling into center of slot area
                    const slotRect = slotArea.getBoundingClientRect();
                    const gameRect = gameContainer.getBoundingClientRect();
                    const targetTop = (slotRect.top - gameRect.top) + 24; // land near top of slot area

                    requestAnimationFrame(() => {
                        el.style.transition = 'top 900ms cubic-bezier(0.2,0.9,0.2,1), opacity 300ms ease-out, transform 700ms cubic-bezier(0.2,0.9,0.2,1)';
                        el.style.top = targetTop + 'px';
                        el.style.opacity = '1';
                        el.style.transform = 'translateX(-50%) scale(1.06)';
                    });

                    // On landing, pop and create confetti
                    setTimeout(() => {
                        try { el.style.transform = 'translateX(-50%) scale(1)'; } catch(e){}
                        createConfettiAt(el, 80);
                        // small screen shake
                        gameContainer.classList.add('screen-shake');
                        setTimeout(() => gameContainer.classList.remove('screen-shake'), 480);
                        setTimeout(() => { try { el.remove(); } catch(e){}; resolve(); }, 720);
                    }, 980);
                } catch (e) { console.log('spawnFallingMultiplier error', e); resolve(); }
            });
        }

        // Perform a random cascade sequence to increase drama (used in mega)
        function performRandomCascade() {
            return new Promise(async resolve => {
                try {
                    const reels = slotArea.querySelectorAll('.reel');
                    const allVisibleSymbols = [];
                    reels.forEach((reel, colIndex) => {
                        const column = reel.querySelector('.symbols-column');
                        const symbols = column.children;
                        // Visible symbols are the first 6 in the DOM due to prepend logic
                        for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
                            if (symbols[rowIndex] && symbols[rowIndex].dataset.symbolId) {
                                allVisibleSymbols.push({
                                    symbolId: symbols[rowIndex].dataset.symbolId,
                                    pos: [colIndex, rowIndex]
                                });
                            }
                        }
                    });

                    // Group symbols by ID
                    const symbolsById = new Map();
                    for (const s of allVisibleSymbols) {
                        if (!symbolsById.has(s.symbolId)) {
                            symbolsById.set(s.symbolId, []);
                        }
                        symbolsById.get(s.symbolId).push(s.pos);
                    }

                    // Find the largest group of identical symbols to explode.
                    // Minimum of 3 symbols to form a group for cascading.
                    let positionsToExplode = [];
                    let maxCount = 2; 
                    for (const [symbolId, positions] of symbolsById.entries()) {
                        if (positions.length > maxCount) {
                            maxCount = positions.length;
                            positionsToExplode = positions;
                        }
                    }

                    if (positionsToExplode.length > 0) {
                        await simultaneousExplodeAndFill(positionsToExplode, 'big');
                    }
                    resolve();
                } catch (e) { console.log('performRandomCascade error', e); resolve(); }
            });
        }

        // Animate adding amount to total over duration (ms)
        function animateCreditToTotal(amount, duration = 2000) {
            return new Promise(resolve => {
                try {
                    const startTotal = totalWinAmount;
                    const target = startTotal + amount;
                    const start = performance.now();

                    function step(now) {
                        const t = Math.min(1, (now - start) / duration);
                        const eased = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // ease-in-out-ish
                        const current = Math.floor(startTotal + (target - startTotal) * eased);
                        totalWinAmountEl.textContent = current;
                        if (t < 1) requestAnimationFrame(step);
                        else {
                            // finish
                            totalWinAmount = target;
                            totalWinAmountEl.textContent = totalWinAmount;
                            try { playSound('coin-sound'); } catch(e){}
                            resolve();
                        }
                    }
                    requestAnimationFrame(step);
                } catch (e) { console.log('animateCreditToTotal error', e); updateTotalWin(amount); resolve(); }
            });
        }

        // Perform Zeus strikes sequentially on the winning positions.
        // Each strike animates a bolt, applies glow/scale and triggers the explosion effect.
        async function performZeusStrikes(winPositions, winLevel) {
            const reels = slotArea.querySelectorAll('.reel');
            // Sort positions left-to-right for strikes
            const ordered = winPositions.slice().sort((a,b) => a[0] - b[0]);

            for (let i = 0; i < ordered.length; i++) {
                const [col, row] = ordered[i];
                const reel = reels[col];
                if (!reel) continue;
                const column = reel.querySelector('.symbols-column');
                const totalSymbols = column.children.length;
                const symbolIndex = totalSymbols - 6 + row;
                const symbolElement = column.children[symbolIndex];
                if (!symbolElement) continue;

                // Brief delay between strikes to build drama
                await zeusLightningStrikeOnSymbol(symbolElement, winLevel);
                // tiny pause between strikes
            }
        }

        // New: trigger a group lightning flash and then explode all winning symbols simultaneously and fill gaps
        async function simultaneousExplodeAndFill(winPositions, winLevel) {
            return new Promise(async resolve => {
                try {
                    // During the explosion sequence only allow the explosion audio to play
                    explosionOnlyMode = true;
                    const reels = slotArea.querySelectorAll('.reel');

                    // Group positions by column
                    const winsByColumn = {};
                    winPositions.forEach(([col, row]) => {
                        if (!winsByColumn[col]) winsByColumn[col] = [];
                        winsByColumn[col].push(row);
                    });

                    // Create a quick lightning flash overlay centered on slot-area
                    const flash = document.createElement('div');
                    flash.className = 'lightning-flash';
                    flash.style.position = 'absolute';
                    flash.style.left = slotArea.getBoundingClientRect().left - gameContainer.getBoundingClientRect().left + 'px';
                    flash.style.top = slotArea.getBoundingClientRect().top - gameContainer.getBoundingClientRect().top + 'px';
                    flash.style.width = slotArea.getBoundingClientRect().width + 'px';
                    flash.style.height = slotArea.getBoundingClientRect().height + 'px';
                    flash.style.background = 'radial-gradient(circle at 50% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.2) 30%, rgba(255,255,255,0) 60%)';
                    flash.style.opacity = '0';
                    flash.style.pointerEvents = 'none';
                    flash.style.zIndex = 9999;
                    gameContainer.appendChild(flash);

                    // small flash in
                    requestAnimationFrame(() => { flash.style.transition = 'opacity 90ms linear'; flash.style.opacity = '1'; });
                    setTimeout(() => { flash.style.opacity = '0'; }, 120);

                    // play a strong lightning sound
                    try { playSound('spin-sound'); } catch(e) {}

                    // add screen shake class
                    gameContainer.classList.add('screen-shake');
                    setTimeout(() => gameContainer.classList.remove('screen-shake'), 520);

                    // For each winning symbol, trigger explosion visuals simultaneously
                    Object.keys(winsByColumn).forEach(colIndex => {
                        const col = parseInt(colIndex);
                        const reel = reels[col];
                        if (!reel) return;
                        const column = reel.querySelector('.symbols-column');
                        const totalSymbols = column.children.length;

                        winsByColumn[col].forEach(row => {
                            const symbolIndex = totalSymbols - 6 + row;
                            const symbolElement = column.children[symbolIndex];
                            if (symbolElement) {
                                    // ensure highlight removed
                                    symbolElement.classList.remove('winning', 'golden-highlight');
                                    // run explosion
                                    try { addExplosionEffect(symbolElement, winLevel); } catch(e){ console.log(e); }
                                    // spawn confetti at the symbol (amount depends on winLevel)
                                    try {
                                        let confCount = 12;
                                        if (winLevel === 'medium') confCount = 18;
                                        else if (winLevel === 'big') confCount = 30;
                                        else if (winLevel === 'mega') confCount = 40; // cap for performance
                                        createConfettiAt(symbolElement, confCount);
                                    } catch(e) { console.log('confetti spawn failed', e); }
                                }
                        });
                    });

                    // Wait for explosion to complete (addExplosionEffect removes elements after ~1100ms)
                    await new Promise(r => setTimeout(r, 1200));

                    // Now fill gaps: for each column insert new symbols equal to number of removed positions
                    Object.keys(winsByColumn).forEach(colIndex => {
                        const col = parseInt(colIndex);
                        const reel = reels[col];
                        if (!reel) return;
                        const column = reel.querySelector('.symbols-column');

                        const removedCount = winsByColumn[col].length;
                        const frag = document.createDocumentFragment();
                        for (let i = 0; i < removedCount; i++) {
                            const symbol = document.createElement('div');
                            symbol.className = 'symbol-item falling';
                            const randomSymbolId = symbols[Math.floor(Math.random() * 9)].id;
                            const img = document.createElement('img');
                            img.loading = 'lazy';
                            img.decoding = 'async';
                            img.draggable = false;
                            img.src = getSymbolSrc(randomSymbolId);
                            img.style.width = '100%';
                            img.style.height = '100%';
                            img.style.objectFit = 'contain';
                            img.style.display = 'block';
                            img.onerror = function() { this.style.display = 'none'; };
                            symbol.appendChild(img);
                            symbol.dataset.symbolId = randomSymbolId;
                            frag.appendChild(symbol);
                        }

                        // Insert new symbols at visibleStartIndex (current children length - 6)
                        const visibleStartIndex = Math.max(0, column.children.length - 6);
                        // Insert fragment's children reversed so order matches visual drop
                        const toInsert = Array.from(frag.children).reverse();
                        toInsert.forEach(sym => {
                            if (column.children[visibleStartIndex]) column.insertBefore(sym, column.children[visibleStartIndex]);
                            else column.appendChild(sym);
                        });
                    });

                    // Wait for falling animation then cleanup classes and re-mark visible
                    setTimeout(() => {
                        const falling = slotArea.querySelectorAll('.symbol-item.falling');
                        falling.forEach(s => s.classList.remove('falling'));

                        const reels2 = slotArea.querySelectorAll('.reel');
                        reels2.forEach(reel => {
                            const column = reel.querySelector('.symbols-column');
                            const syms = column.children;
                            for (let i = 0; i < syms.length; i++) {
                                if (i >= syms.length - 6) {
                                    syms[i].classList.add('active');
                                    syms[i].classList.remove('inactive');
                                } else {
                                    syms[i].classList.add('inactive');
                                    syms[i].classList.remove('active');
                                }
                            }
                        });

                        try { if (flash.parentNode) flash.remove(); } catch(e){}
                        // Re-enable normal sounds
                        explosionOnlyMode = false;
                        resolve();
                    }, 520);

                } catch (e) {
                    console.log('simultaneousExplodeAndFill error', e);
                    try { if (flash && flash.parentNode) flash.remove(); } catch(e){}
                    explosionOnlyMode = false;
                    resolve();
                }
            });
        }

        // Create a targeted lightning bolt from top center to the symbol, then explode the symbol
        function zeusLightningStrikeOnSymbol(symbolElement, winLevel) {
            return new Promise(resolve => {
                try {
                    const gameRect = gameContainer.getBoundingClientRect();
                    const symRect = symbolElement.getBoundingClientRect();
                    const startX = gameRect.width * 0.5; // top-center
                    const startY = 0;
                    const endX = symRect.left - gameRect.left + symRect.width / 2;
                    const endY = symRect.top - gameRect.top + symRect.height / 2;

                    // Create svg overlay for bolt
                    const xmlns = 'http://www.w3.org/2000/svg';
                    const svg = document.createElementNS(xmlns, 'svg');
                    svg.setAttribute('viewBox', `0 0 ${gameRect.width} ${gameRect.height}`);
                    svg.style.position = 'absolute';
                    svg.style.left = '0';
                    svg.style.top = '0';
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.pointerEvents = 'none';
                    svg.style.zIndex = 99990;

                    const path = document.createElementNS(xmlns, 'path');
                    // Simple jagged path with mid-control randomness
                    const midX = (startX + endX) / 2 + (Math.random() - 0.5) * 80;
                    const midY = (startY + endY) / 2 + (Math.random() - 0.5) * 60;
                    const d = `M ${startX} ${startY} Q ${midX} ${midY} ${endX} ${endY}`;
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', '#E8FBFF');
                    path.setAttribute('stroke-width', 4);
                    path.setAttribute('fill', 'none');
                    path.style.filter = 'drop-shadow(0 0 18px rgba(232,251,255,0.9))';
                    path.style.opacity = '0';

                    svg.appendChild(path);
                    gameContainer.appendChild(svg);

                    // Animate bolt appearing fast
                    const length = path.getTotalLength();
                    path.style.strokeDasharray = length;
                    path.style.strokeDashoffset = length;

                    const boltDur = 80 + Math.random() * 120;
                    path.animate([
                        { strokeDashoffset: length, opacity: 0 },
                        { strokeDashoffset: length * 0.05, opacity: 1 },
                        { strokeDashoffset: 0, opacity: 1 },
                        { strokeDashoffset: -length * 0.4, opacity: 0 }
                    ], { duration: boltDur, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });

                    // short flash at impact
                    setTimeout(() => {
                        // Apply intense glow to symbol
                        symbolElement.classList.add('golden-highlight');
                        symbolElement.style.transition = 'transform 120ms ease-out, opacity 120ms linear';
                        symbolElement.style.transform = 'scale(1.12)';
                    }, boltDur * 0.6);

                    // Explosion timing
                    const explodeAt = boltDur + 60; // after bolt
                    setTimeout(() => {
                        // add explosion effect (shards + fade)
                        addExplosionEffect(symbolElement, winLevel);
                        // make symbol vanish quickly
                        try { symbolElement.style.opacity = '0'; } catch(e){}
                    }, explodeAt);

                    // cleanup svg and resolve after explosion completes
                    setTimeout(() => {
                        try { svg.remove(); } catch(e){}
                        resolve();
                    }, explodeAt + 260); // explosion 0.15-0.25s, give buffer

                } catch (e) {
                    console.log('zeusLightningStrikeOnSymbol error', e);
                    resolve();
                }
            });
        }

        // Floating win counter removed  keep compatibility stub
        function animateWinCounter(amount) { return Promise.resolve(); }

        // Initialize cinematic controller
        let cinematicController = new CinematicWinController();
        
        // Compute and set CSS variable for symbol pixel size so items stay fixed height
        function setSymbolPixelSize() {
            try {
                const visibleCount = 6;
                const spinLength = TOTAL_SPIN_SYMBOLS;
                const firstReel = slotArea.querySelector('.reel');
                if (!firstReel) return;
                const reelViewport = firstReel.getBoundingClientRect();
                if (!reelViewport || !reelViewport.height) return;
                const symbolPx = Math.floor(reelViewport.height / visibleCount);
                // set CSS var on slotArea so CSS picks it up
                slotArea.style.setProperty('--symbol-height', `${symbolPx}px`);

                // set exact column heights in px so spin math is stable
                const columns = slotArea.querySelectorAll('.symbols-column');
                columns.forEach(col => {
                    col.style.height = `${symbolPx * spinLength}px`;
                    // ensure each child uses the CSS var (in case some inline heights remain)
                    Array.from(col.children).forEach(ch => {
                        try { ch.style.height = 'var(--symbol-height)'; } catch(_){}
                    });
                });
            } catch (e) {
                console.log('setSymbolPixelSize error', e);
            }
        }

        // Recompute symbol size on resize
        window.addEventListener('resize', () => {
            try { setSymbolPixelSize(); } catch (e) {}
        });
        // Attempt to load external spin config (if present) so you can edit states/texts/wins
        // Initialize game after attempting to load config
        (async () => {
            // Initialize minimal welcome UI and slot area
            try {
                if (title) title.textContent = 'Battle for the Power of Olympus';
                if (subtitle) subtitle.textContent = '';
                if (spinBtn) { spinBtn.textContent = 'SPIN'; spinBtn.classList.remove('collect-btn','bonus-btn'); spinBtn.disabled = false; }
            } catch (e) {}
            spinCount = 0;
            initSlotArea(generateRandomGrid());

            // Ensure Zeus is visually centered before any spins start
            try {
                // Wait for next frame/layout to ensure container sizes are correct
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        try {
                            const zEl = document.querySelector('.zeus-container');
                            if (zEl) {
                                zEl.classList.add('floating-center');
                                zEl.classList.remove('behind');
                            }
                            if (zeusController) {
                                // Recompute anchors now that layout is stable
                                if (typeof zeusController._updateAnchors === 'function') zeusController._updateAnchors();
                                // Try to position Zeus exactly at the center anchor
                                if (typeof zeusController.setToAnchor === 'function') zeusController.setToAnchor('center', true);
                                if (typeof zeusController.setToCenter === 'function') zeusController.setToCenter();
                                if (typeof zeusController.apply === 'function') zeusController.apply();
                                if (typeof zeusController.start === 'function') zeusController.start();
                                if (typeof zeusController.startHover === 'function') zeusController.startHover(4, 1.2);
                            }
                        } catch (err) {
                            console.log('zeus center delayed init error', err);
                        }
                    }, 40);
                });
            } catch (e) { console.log('zeus center init error', e); }
        })();
    </script>
</body>
</html>